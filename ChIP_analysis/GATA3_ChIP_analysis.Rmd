---
title: GATA3 ChIP-seq analysis 
author:
- Siyu Sun
- Michael J. Guertin
header-includes:
- \usepackage{color}
- \usepackage{float}
- \DeclareUnicodeCharacter{2212}{-}
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    toc: true
fontsize: 14pt
geometry: margin=1in
---


# ChIP-seq experiments

ChIP-seq measures protein abundance on DNA and one can quantify
protein modifications if an antibody to the modification is
available. 

# ChIP-seq experimental design

Controls are important.  An IgG (or mock) IP is superior to input as
a control. I am happy to discuss the design of ChIP-seq experiments 
with you **before** you generate any data. It is much easier to design
the proper experiments and controls and analyze the data compared to
the alternative of trying to salvage poorly controlled experiments.

# Info about this experiment

MCF7 cells with the dTAG-GATA3 (clone522) grow in charcoal stripped media (ER deprived) are treated under 3 conditions: 1) CC: null+null; 2) CE: null+ E2; 3) dE: dTAG+E2. \
Cells are ChIPed with IgG, CTCF, GATA3, ER, respectively; plus an parallel-ChiP of CTCF and ER.

# ChIP-seq analysis

First we name the experiments with the trailing name being `PE1` or
`PE2` for paired end data. 

```{r engine='bash', eval=F, echo=TRUE}
for i in *_S*R1_001.fastq.gz
do
    nm=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_S" '{print $1}')
    echo $nm
	two=$(echo $i | awk -F"/" '{print $NF}' | awk -F"R1_001.fastq.gz" '{print $1}')
	mv $i ${nm}_PE1.fastq.gz
	mv ${two}R2_001.fastq.gz ${nm}_PE2.fastq.gz
done
```


## Cut off the adapter with `cutadapt`

In our daily workflow in the lab we use
`cutadapt` to remove adapter sequences. The options we use below are:

- `-j` for the number of cores to use
- `-m` specifies the minimal length of a read to keep after adapter sequence removal
- `-O` is the number of bases to trim off the end of the read if it overlaps with the adapter sequence 
- `-a` adapter sequence of PE1 reads 
- `-A` adapter sequence of PE2 reads
- `-o` PE1 output file 
- `-p` PE2 output file

If the genome contains 25% of each base, then you would expect one quarter of the
reads that have no adapter to have the trailing base
trimmed. Likewise, approximately 1/16 of the remaining
reads without the adapter will have the final two bases
trimmed. Technically these values are not exact, because the reads with
matches to longer trailing k-mers (in this case 19-mers) would be
removed first, then 18-mer matches removed, etcetera...  \

The `-a` and `-A`
options are the adapter sequences of the PE1 and PE2 reads.  The
output file is `-o` (PE1) and `-p` PE2. The last two positional
areguments are the input `fastq` files. We save the output
to a log file.

```{r engine='bash', eval=F, echo=TRUE}
module load cutadapt
for i in *PE1.fastq.gz
do
    name=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_PE1" '{print $1}')
	echo $name
	echo unzipping $i
	gunzip $i
	echo unzipping ${name}_PE2.fastq.gz
	gunzip ${name}_PE2.fastq.gz
	cutadapt -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCA -A AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT -j 8 -m 10 -O 1 -o ${name}_PE1_no_adapt.fastq -p ${name}_PE2_no_adapt.fastq ${name}_PE1.fastq ${name}_PE2.fastq 2>&1 | tee ${name}_cutadapt.log
done
```

## Align to the human genome

First we want to generate a folder in the convenient directory and name it as Genome. We will save all the genome files here. `cd` to this working directory, we are getting reference genome and chrom.sizes file from the USCS genome server, and build the genome index with `bowtie2-build`.

```{r engine='bash', eval=F, echo=TRUE}
#! /bin/sh

#SBATCH --job-name=getrefgenome.sh     # name for job
#SBATCH -N 1
#SBATCH -n 1
#SBATCH -c 32
#SBATCH -p general
#SBATCH --qos=general
#SBATCH --mem=32G
#SBATCH --mail-type=ALL
#SBATCH --mail-user=ssun@uchc.edu
#SBATCH -o getrefgenome.sh_%j.out
#SBATCH -e getrefgenome.sh_%j.err

module load genometools/1.5.10
module load bowtie2
export PATH=$PATH:/home/FCAM/ssun/packages

wget https://hgdownload.cse.ucsc.edu/goldenpath/hg38/bigZips/hg38.fa.gz
gunzip hg38.fa.gz
bowtie2-build hg38.fa hg38

wget https://hgdownload-test.gi.ucsc.edu/goldenPath/hg38/bigZips/hg38.chrom.sizes
```

Now we are aligning to the `hg38.fa` genome. The difference between ChIPseq data and PRO is that the ChIP libraries are paired end. Note the `-1` and
`-2` options for the respective paired-end `fastq` files. There is no
need to save the output `sam` file, so the output is piped to
`samtools` to convert to `bam`, then sorted by name (`-n`) so paired
end reads are adjacent in the file, then piped to `samtools fixmate`
which adds information about the fragment length by comparing the PE1
and PE2 coordinates, then the files are sorted by coordinate, then
piped to `samtools markdup` to remove duplicate reads. Duplicate reads
have the same PE1 and PE2 ends. This is very unlikely to happen by
chance unless you sequence to very high read depth, so these reads are
considered PCR amplicon duplicates. The `fixmate` step is necessary to
pipe to `markdup`. We use the entire DNA fragment for making the
browser tracks, which is accomplished by converted the paired-end
`bam` file to a `bed12` and taking out discordant reads. We also
normalize to read depth. \
```{r engine='bash', eval=F, echo=TRUE}
#!/bin/bash
#SBATCH --job-name=chip_alignment_230718.sh     # name for job
#SBATCH -N 1                  
#SBATCH -n 1                 
#SBATCH -c 32                  
#SBATCH -p general           
#SBATCH --qos=general       
#SBATCH --mem=32G               
#SBATCH --mail-type=ALL 
#SBATCH --mail-user=ssun@uchc.edu
#SBATCH -o chip_alignment_230718.sh_%j.out
#SBATCH -e chip_alignment_230718.sh_%j.err

hostname

name=230718

# I have seqOutBias and other packages export to my Path
export PATH=$PATH:/home/FCAM/ssun/packages/

module load samtools/1.16.1
module load genometools/1.5.10
module load ucsc_genome/2012.05.22
module load rust
module load bowtie2
module load bedtools


sizes=/home/FCAM/ssun/Genome/hg38.chrom.sizes

genome=/home/FCAM/ssun/Genome/hg38.fa
genome_index=/home/FCAM/ssun/Genome/hg38_bt2/hg38
ncore=30 
tallymer=hg38.tal_42.gtTxt.gz

bowtie2 -p $ncore --maxins 800 -x $genome_index -1 ${name}_PE1_no_adapt.fastq -2 ${name}_PE2_no_adapt.fastq | samtools sort -@ $ncore -n -o ${name}.bw.bam
gzip ${name}_PE1_no_adapt.fastq
gzip ${name}_PE2_no_adapt.fastq
gzip ${name}_PE2.fastq
gzip ${name}_PE1.fastq
samtools fixmate -m ${name}.bw.bam - | samtools sort -@ $ncore - | samtools markdup -s -r - ${name}.hg38.bam
seqOutBias ${genome} ${name}.hg38.bam --shift-counts --no-scale \
                                      --bw=${name}.bigWig --read-size=42 --tallymer=$tallymer 2>&1 | tee ${name}_seqOutBias.log
samtools sort -@ $ncore -n -o ${name}.sorted.bam ${name}.hg38.bam
# the above samtools -n is sorting files by queryname, which is important for the next bedtools bamtobed command with the -bedpe flag; 
# the bedtools bamtobed -bedpe is generating warning signs:
# *****WARNING: Query {...} is marked as paired, but its mate does not occur next to it in your BAM file.  Skipping.
# This might due to some single end sequences, I checked the fraction of these not paired sequences, it is <1.5%, so we don't need to worry.
bedtools bamtobed -i ${name}.sorted.bam -bedpe > ${name}_bed12.bed

awk '$1==$4 {print $0}' ${name}_bed12.bed | awk '{OFS="\t";} {print $1, $2, $6}' | awk '$1!="." && $3>$2 && (($3 - $2)<2000) {print $0}' | sort -k1,1 -k2,2n > ${name}_read_span.bed
genomeCoverageBed -bg -i ${name}_read_span.bed -g $sizes > ${name}.bedGraph
depth=`awk -F'\t' '{sum+=$5;}END{print sum;}' ${name}.hg38_not_scaled.bed`
scaled=$(bc <<< "scale=3 ; 10000000 / $depth")
echo $scaled
awk -v scaled="$scaled" '{OFS="\t";} {print $1, $2, $3, $4*scaled}' ${name}.bedGraph > ${name}_normalized.bedGraph
wigToBigWig -clip ${name}_normalized.bedGraph $sizes ${name}_normalized.bigWig
```

## Run the previous chunk in parallel 

Now we are generating tallymer files and table use `seqOutBias` outside the loop, and then run the previous chunk in parallel. \
We need to know the read size of our library. Here the read size is 42.\
```{r engine='bash', eval=F, echo=TRUE}
#Compute mappability for the given read length and the k-mer that corresponds to each possible read alignment position
#time-consuming but only need to run this one time
seqOutBias seqtable hg38.fa --read-size=42


file=chip_alignment_230718.sh 
for i in *_PE1.fastq
do
    nm=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_PE1.fastq" '{print $1}')
    fq=$(echo $i | rev | cut -f 1 -d '/' | rev)
    echo $nm
    echo $fq
    sed -e "s/230718/${nm}/g" "$file" > chip_alignment_${nm}.sh
    sbatch chip_alignment_${nm}.sh
    sleep 1
done

```


# Combining replicates for the genome browser

Usually we combine replicates into a single track for visualization
and we compare the tracks between conditions. It is important that we
read-depth normalize before we combine the signal from each
replicate. Otherwise, we would be weighting replicates differently;
for example, if a library is sequenced to twice the read depth and we
combine first then read depth normalize, then the more high coverage
data is weighted twice as much in the final visualization. All the
relevant track files are here:
[http://guertinlab.cam.uchc.edu/znf143_hub/](http://guertinlab.cam.uchc.edu/znf143_hub/)

```{r engine='bash', eval=F, echo=TRUE}
#!/bin/bash
#SBATCH --job-name=combine_rep.sh     # name for job
#SBATCH -N 1                  
#SBATCH -n 1                 
#SBATCH -c 32                  
#SBATCH -p general           
#SBATCH --qos=general       
#SBATCH --mem=32G               
#SBATCH --mail-type=ALL 
#SBATCH --mail-user=ssun@uchc.edu
#SBATCH -o combine_rep.sh_%j.out
#SBATCH -e combine_rep.sh_%j.err

module load ucsc_genome/2012.05.22
sizes=/home/FCAM/ssun/Genome/hg38.chrom.sizes

for i in *MCF*rep1_PE1.fastq.gz
do
    nm=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_PE1.fastq.gz" '{print $1}')
    name=$(echo $nm | awk -F"_rep1" '{print $1}')
    echo $name
    reps=$(ls ${name}_rep*normalized.bigWig | wc -w | bc)
	echo $reps
    files=$(ls ${name}_rep*normalized.bigWig)
	echo $files
    bigWigMerge $files tmp.bg
    scaleall=$(bc <<< "scale=4 ; 1.0 / $reps")
    echo scale:
    echo $scaleall
    awk -v scaleall="$scaleall" '{OFS="\t";} {print $1, $2, $3, $4*scaleall}' tmp.bg > ${name}_normalized.bedGraph
	rm tmp.bg
	wigToBigWig ${name}_normalized.bedGraph $sizes ${name}.bigWig
    awk -v var="$name" 'BEGIN {  print "browser position chr11:5,289,521-5,291,937"; print "track type=bedGraph name=\"" var "\" description=\"" var "_bedGraph\" visibility=full autoScale=on alwaysZero=on color=0,0,0"}  { print $0}' ${name}_normalized.bedGraph > ${name}_header_normalized.bedGraph
    gzip ${name}_header_normalized.bedGraph
done

# side note: only few files has replicates: CTCF_CC (2 reps), ER_CE (2 reps), and GATA_CC (3reps)
```

```{r engine='bash', eval=F, echo=TRUE}
# we have single replicate for IgG_dE, IgG_CE, and IgG_CC. Here I am trying to merge the three IgG files together

#!/bin/bash
module load ucsc_genome/2012.05.22
sizes=/home/FCAM/ssun/Genome/hg38.chrom.sizes
name=MCF7_dTAGGATA522_IgG
reps=3

files=$(ls ${name}*_normalized.bigWig)
echo $files

bigWigMerge $files tmp.bg
scaleall=$(bc <<< "scale=4 ; 1.0 / $reps")
echo scale:
echo $scaleall
awk -v scaleall="$scaleall" '{OFS="\t";} {print $1, $2, $3, $4*scaleall}' tmp.bg > ${name}_normalized.bedGraph
rm tmp.bg
wigToBigWig ${name}_normalized.bedGraph $sizes ${name}.bigWig
awk -v var="$name" 'BEGIN {  print "browser position chr11:5,289,521-5,291,937"; print "track type=bedGraph name=\"" var "\" description=\"" var "_bedGraph\" visibility=full autoScale=on alwaysZero=on color=0,0,0"}  { print $0}' ${name}_normalized.bedGraph > ${name}_header_normalized.bedGraph
gzip ${name}_header_normalized.bedGraph

```

```{r engine='bash', eval=F, echo=TRUE}
for i in *MCF*PE1.fastq.gz
do
    name=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_PE1.fastq.gz" '{print $1}')
    mkdir ${name}_files
	  mv ${name}* ./${name}_files
done
```

trackhub link: http://guertinlab.cam.uchc.edu/GATA3_hub/hub.txt \


# Peak calling

We use `Macs3 callpeaks` to identify TF binding sites. It takes the treatment files against the control genomic input. \
In the below chunk, I am taking all sorted bam files with same ChIP factor as my input (`-t`) to account for all possible binding regions; I have one GATA ChIP with degradation treatment, this will be considered separately as one treatment. My control genomic input is all the IgG file (`-c`). \
The reason we want to call peaks on all files of same ChIP factors is that: taking intersection of peaks between replicates/conditions will result in high false negative rates. We may lose important binding regions for transcription factor analysis. Here we are doing a compromise to call every peaks on all files and later in downstream analysis we will decide the functional peaks. \

```{r engine='bash', eval=F, echo=TRUE}
#! /bin/sh
#SBATCH --job-name=chip_peak_calling.sh     # name for job
#SBATCH -N 1
#SBATCH -n 1
#SBATCH -c 2
#SBATCH -p general
#SBATCH --qos=general
#SBATCH --mem=32G
#SBATCH --mail-type=ALL
#SBATCH --mail-user=ssun@uchc.edu
#SBATCH -o chip_peak_calling.sh_%j.out
#SBATCH -e chip_peak_calling.sh_%j.err

hostname
module load macs3

mkdir temp_macs

# CTCF (merged from CTCF_CC_2files, CE, dE); my -c input: IgG (control, merged from IgG_dE,CE,CC)
macs3 callpeak --call-summits -t *_CTCF_*bam -c *IgG*bam -n CTCF_ChIP -g hs -q 0.01 --keep-dup all -f BAMPE --nomodel --tempdir temp_macs
# ER (merged from ER_CE_2files,dE)
macs3 callpeak --call-summits -t *_ER_*bam -c *IgG*bam -n ER_ChIP -g hs -q 0.01 --keep-dup all -f BAMPE --nomodel --tempdir temp_macs
# GATA (merged from GATA_CC,CE,dE)
macs3 callpeak --call-summits -t *GATA_C*bam -c *IgG*bam -n GATActrl_ChIP -g hs -q 0.01 --keep-dup all -f BAMPE --nomodel --tempdir temp_macs
# GATA_degrade (gata_dE)
macs3 callpeak --call-summits -t *GATA_d*bam -c *IgG*bam -n GATAdegrade_ChIP -g hs -q 0.01 --keep-dup all -f BAMPE --nomodel --tempdir temp_macs
# GATA all
macs3 callpeak --call-summits -t *_GATA_*bam -c *IgG*bam -n GATA_ChIP -g hs -q 0.01 --keep-dup all -f BAMPE --nomodel --tempdir temp_macs
# CTER
macs3 callpeak --call-summits -t *CTER_*bam -c *IgG*bam -n CTER_ChIP -g hs -q 0.01 --keep-dup all -f BAMPE --nomodel --tempdir temp_macs
```

## Removing peaks on contigs and within blacklisted regions

Google "blacklisted genomic regions" we can find a
set of region in the genome in `bed` format that have an over-representation of
reads regardless of the experiment. We also remove peaks on non-canonical chromosomes with
`grep -v`. \

All intervals in the summits file span one base, and we use `bedtools slop` to change boundaries by adding a fixed number of bases in each direction (`-b`). These 101 base intervals will be used as input for de novo motif analysis. The 401 base intervals will be used to calculate peak intensity. The rationale for a smaller window for motif analysis is the following: \
1) the motif is typically very close to the peak summit, \
2) larger window increases the computation time substantially, and \
3) the flanking sequence is less enriched for the relevant motifs and de novo motif analysis is less sensitive with higher noise relative to background. \

We use a standard window size to calculate peak intensity, but we use a much wider window because signal 200 bases up or downstream can result from signal. We could increase the window to 600 bases and that would be fine as well. You can vary this window systematically and determine if varying the window affects the relative peak intensity rank. We use the same window size for each peak because otherwise wider windows (note the narrowPeaks file outputs are variable width) would inherently have more reads. 

```{r engine='bash', eval=F, echo=TRUE}
#! /bin/sh
#SBATCH --job-name=remove_peak.sh     # name for job
#SBATCH -N 1
#SBATCH -n 1
#SBATCH -c 2
#SBATCH -p general
#SBATCH --qos=general
#SBATCH --mem=32G
#SBATCH --mail-type=ALL
#SBATCH --mail-user=ssun@uchc.edu
#SBATCH -o remove_peak.sh_%j.out
#SBATCH -e remove_peak.sh_%j.err
module load deeptools/3.5.0
module load bedtools
wget https://github.com/Boyle-Lab/Blacklist/raw/master/lists/hg38-blacklist.v2.bed.gz
gunzip hg38-blacklist.v2.bed.gz
blacklist=hg38-blacklist.v2.bed
sizes=/home/FCAM/ssun/Genome/hg38.chrom.sizes


for i in *_summits.bed
do
	name=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_summits.bed" '{print $1}')
	echo $name
	grep -v "random" ${name}_summits.bed | grep -v "chrUn" | grep -v "chrEBV" | grep -v "chrM" | grep -v "alt" | intersectBed -v -a - -b $blacklist > ${name}_summits_final.bed
	slopBed -b 50 -i ${name}_summits_final.bed -g $sizes  | sort -k1,1 -k2,2n > ${name}_summit_100window.bed
   	slopBed -b 200 -i ${name}_summits_final.bed -g $sizes  | sort -k1,1 -k2,2n > ${name}_summit_400window.bed
done
```

# De novo motif analysis at peaks

## gata3 peaks
```{r engine='bash', eval=F, echo=TRUE}
#CTCF_ChIP_summit_100window.bed  
#GATA_ChIP_summit_100window.bed
#CTER_ChIP_summit_100window.bed  
#GATActrl_ChIP_summit_100window.bed
#ER_ChIP_summit_100window.bed    
#GATAdegrade_ChIP_summit_100window.bed

module load meme/5.4.1
module load bedtools

genome=/home/FCAM/ssun/Genome/hg38.fa
sizes=/home/FCAM/ssun/Genome/hg38.chrom.sizes

name=GATA_ChIP
fastaFromBed -fi $genome -bed ${name}_summit_100window.bed -fo ${name}_summit_100window.fasta

meme -oc ${name}_motif.meme_output -nmotifs 2 -objfun classic -csites 20000 -searchsize 0 -minw 10 -maxw 15 -revcomp -dna -markov_order 3 -maxsize 100000000 ${name}_summit_100window.fasta

#Just did the top 2000 peaks to make it faster
sort -nrk5,5 ${name}_summit_100window.bed | head -n 2000 > ${name}_top2000_summit_100window.bed
name=${name}_top2000
fastaFromBed -fi $genome -bed ${name}_summit_100window.bed -fo ${name}_summit_100window.fasta
meme -oc ${name}_motif.meme_output -nmotifs 2 -objfun classic -csites 20000 -searchsize 0 -minw 10 -maxw 15 -revcomp -dna -markov_order 3 -maxsize 100000000 ${name}_summit_100window.fasta
```


## ER peaks
```{r engine='bash', eval=F, echo=TRUE}
name=ER_ChIP
fastaFromBed -fi $genome -bed ${name}_summit_100window.bed -fo ${name}_summit_100window.fasta

meme -oc ${name}_motif.meme_output -nmotifs 2 -objfun classic -csites 20000 -searchsize 0 -minw 10 -maxw 15 -revcomp -dna -markov_order 3 -maxsize 100000000 ${name}_summit_100window.fasta

#Just did the top 2000 peaks to make it faster
sort -nrk5,5 ${name}_summit_100window.bed | head -n 2000 > ${name}_top2000_summit_100window.bed
name=${name}_top2000
fastaFromBed -fi $genome -bed ${name}_summit_100window.bed -fo ${name}_summit_100window.fasta
meme -oc ${name}_motif.meme_output -nmotifs 2 -objfun classic -csites 20000 -searchsize 0 -minw 10 -maxw 15 -revcomp -dna -markov_order 3 -maxsize 100000000 ${name}_summit_100window.fasta
```

We have found two motifs with top 2000 most significant peaks, they match to ESR1 and Sox:
```{r engine='bash', eval=F, echo=TRUE}
# motif plot
```


# Differential expression analysis with DEseq2 

## Counting size factors from libraries

Here we use `samtools` to count the read size of each library. The Flag is user-defined, the flag `0x3` in the command means read paired and read mapped in proper pair. We can use this website: https://broadinstitute.github.io/picard/explain-flags.html to understand what property and what flag we want to specify.

```{r engine='bash', eval=F, echo=TRUE}

#calculate the size factors of each library

module load samtools/1.12
for i in ER
do
  echo $i
  > ${i}_header.txt
  > ${i}_reads.txt
  for j in MCF7_dTAGGATA522*_${i}_*.bam
  do
    echo $j
    name=$(echo $j | awk -F".sorted.bam" '{print $1}')
    echo $name | paste ${i}_header.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_header.txt
    reads=`samtools view -c -f 0x3 $j`
    echo $reads | paste ${i}_reads.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_reads.txt
  done  
  cat ${i}_header.txt ${i}_reads.txt > ${i}_tmp.txt
  mv ${i}_tmp.txt ${i}_reads.txt
  rm ${i}_header.txt
done 

for i in GATA
do
  echo $i
  > ${i}_header.txt
  > ${i}_reads.txt
  for j in MCF7_dTAGGATA522*_${i}_*.bam
  do
    echo $j
    name=$(echo $j | awk -F".sorted.bam" '{print $1}')
    echo $name | paste ${i}_header.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_header.txt
    reads=`samtools view -c -f 0x3 $j`
    echo $reads | paste ${i}_reads.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_reads.txt
  done  
  cat ${i}_header.txt ${i}_reads.txt > ${i}_tmp.txt
  mv ${i}_tmp.txt ${i}_reads.txt
  rm ${i}_header.txt
done 

for i in CTCF
do
  echo $i
  > ${i}_header.txt
  > ${i}_reads.txt
  for j in MCF7_dTAGGATA522*_${i}_*.bam
  do
    echo $j
    name=$(echo $j | awk -F".sorted.bam" '{print $1}')
    echo $name | paste ${i}_header.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_header.txt
    reads=`samtools view -c -f 0x3 $j`
    echo $reads | paste ${i}_reads.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_reads.txt
  done  
  cat ${i}_header.txt ${i}_reads.txt > ${i}_tmp.txt
  mv ${i}_tmp.txt ${i}_reads.txt
  rm ${i}_header.txt
done 


for i in CTER 
do
  echo $i
  > ${i}_header.txt
  > ${i}_reads.txt
  for j in MCF7_dTAGGATA522*_${i}_*.bam
  do
    echo $j
    name=$(echo $j | awk -F".sorted.bam" '{print $1}')
    echo $name | paste ${i}_header.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_header.txt
    reads=`samtools view -c -f 0x3 $j`
    echo $reads | paste ${i}_reads.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_reads.txt
  done  
  cat ${i}_header.txt ${i}_reads.txt > ${i}_tmp.txt
  mv ${i}_tmp.txt ${i}_reads.txt
  rm ${i}_header.txt
done 


for i in IgG
do
  echo $i
  > ${i}_header.txt
  > ${i}_reads.txt
  for j in MCF7_dTAGGATA522*_${i}_*.bam
  do
    echo $j
    name=$(echo $j | awk -F".sorted.bam" '{print $1}')
    echo $name | paste ${i}_header.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_header.txt
    reads=`samtools view -c -f 0x3 $j`
    echo $reads | paste ${i}_reads.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_reads.txt
  done  
  cat ${i}_header.txt ${i}_reads.txt > ${i}_tmp.txt
  mv ${i}_tmp.txt ${i}_reads.txt
  rm ${i}_header.txt
done 

```

## R

Now we are moving to the R section. We will load `R/4.1.2`, which has many pre-installed libraries on Xanadu. 

```{r, engine='R', eval=F, echo=TRUE}
module load R/4.1.2 # this version of `R` on Xanadu has many of our libraries pre-installed. 

R 

#libraries
library(DESeq2)
library(lattice)
library(dplyr)
library(ggplot2)
library(limma)
library(bigWig)

#functions on github
source('https://raw.githubusercontent.com/mjg54/znf143_pro_seq_analysis/master/docs/ZNF143_functions.R')

#new functions
get.counts.interval <- function(df, path.to.bigWig, file.prefix = 'H') {
    vec.names = c()
    inten.df=data.frame(matrix(ncol = 0, nrow = nrow(df)))
    
    for (mod.bigWig in Sys.glob(file.path(path.to.bigWig, paste(file.prefix, "*.bigWig", sep ='')))) {
        factor.name = strsplit(strsplit(mod.bigWig, "/")[[1]][length(strsplit(mod.bigWig, "/")[[1]])], '.bigWig')[[1]][1]
        print(factor.name)
        vec.names = c(vec.names, factor.name)
        loaded.bw = load.bigWig(mod.bigWig)
        print(mod.bigWig)
        mod.inten = bed.region.bpQuery.bigWig(loaded.bw, df, abs.value = TRUE)
        inten.df = cbind(inten.df, mod.inten)
    }
    colnames(inten.df) = vec.names
    r.names = paste(df[,1], ':', df[,2], '-', df[,3], sep='')
    row.names(inten.df) = r.names
    return(inten.df)
}

ma.plot.lattice <- function(ma.df, filename = 'file.name', 
         title.main = "Differential ChIP-seq Accessibility", ymin = -4,
         ymax=4,
         col = c("grey90",  "grey60", "#ce228e" , "#2290cf"))
  {
  pdf(paste("MA_plot_", filename, ".pdf", sep=''), 
      useDingbats = FALSE, width=3.83, height=3.83);
  print(xyplot(ma.df$log2FoldChange ~ log(ma.df$baseMean, base=10),
               groups=ma.df$response,
               col= col, ylim=c(ymin,ymax),
                main=title.main, scales="free", aspect=1, pch=20, cex=0.5,
               ylab=expression("log"[2]~"ChIP-seq change"), 
               xlab=expression("log"[10]~"Mean of Normalized Counts"),
               par.settings=list(par.xlab.text=list(cex=1.1,font=2), 
                                 par.ylab.text=list(cex=1.1,font=2))));
  dev.off()
  }


categorize.deseq.df.repressed <- function(df, fdr = 0.1, log2fold = 0.0, treat
= 'Auxin') {

     df.activated = data.frame(matrix(nrow = 0, ncol = 0))
     df.repressed = data.frame(matrix(nrow = 0, ncol = 0))
	 df.unchanged = data.frame(matrix(nrow = 0, ncol = 0))
     df.dregs = data.frame(matrix(nrow = 0, ncol = 0))
     if (nrow(df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold,]) != 0) {
     	df.activated = df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold,]
	df.activated$response = paste(treat, 'Activated')
	}

     if (nrow(df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold,]) != 0) {
     	df.repressed = df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold,]
	df.repressed$response = paste(treat, 'Repressed')
	}
    
    if (nrow(df[df$padj > 0.5 & !is.na(df$padj) & abs(df$log2FoldChange) < 0.25,]) != 0) {
	df.unchanged = df[df$padj > 0.5 & !is.na(df$padj) & abs(df$log2FoldChange) < 0.25,]
    df.unchanged$response = paste(treat, 'Unchanged')
	}

    if (nrow(df[!(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold) &
                  !(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold) &
                  !(df$padj > 0.5 & !is.na(df$padj) &
    		  abs(df$log2FoldChange) < 0.25), ]) != 0) {
	df.dregs = df[!(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold) &
                  !(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold) &
                  !(df$padj > 0.5 & !is.na(df$padj) &
    		  abs(df$log2FoldChange) < 0.25), ]
	df.dregs$response = paste(treat, 'All Other Genes')
	}
	print(head(df.repressed))
	print(head(df.activated))
	print(head(df.dregs))
	print(head(df.unchanged))
    df.effects.lattice = df.repressed
    #rbind(df.activated, 
    #      df.unchanged, 
    #      df.repressed, 
    #      df.dregs)
	print(head(df.effects.lattice))
    #df.effects.lattice$response = factor(df.effects.lattice$response)
	#df.effects.lattice$response = relevel(df.effects.lattice$response, ref = paste(treat, 'Unchanged'))
	#df.effects.lattice$response = relevel(df.effects.lattice$response, ref = paste(treat, 'All Other Genes'))
    return(df.effects.lattice)
}

categorize.deseq.df.activated <- function(df, fdr = 0.1, log2fold = 0.0, treat
= 'Auxin') {

     df.activated = data.frame(matrix(nrow = 0, ncol = 0))
     df.repressed = data.frame(matrix(nrow = 0, ncol = 0))
	 df.unchanged = data.frame(matrix(nrow = 0, ncol = 0))
     df.dregs = data.frame(matrix(nrow = 0, ncol = 0))
     if (nrow(df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold,]) != 0) {
     	df.activated = df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold,]
	df.activated$response = paste(treat, 'Activated')
	}

     if (nrow(df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold,]) != 0) {
     	df.repressed = df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold,]
	df.repressed$response = paste(treat, 'Repressed')
	}
    
    if (nrow(df[df$padj > 0.5 & !is.na(df$padj) & abs(df$log2FoldChange) < 0.25,]) != 0) {
	df.unchanged = df[df$padj > 0.5 & !is.na(df$padj) & abs(df$log2FoldChange) < 0.25,]
    df.unchanged$response = paste(treat, 'Unchanged')
	}

    if (nrow(df[!(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold) &
                  !(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold) &
                  !(df$padj > 0.5 & !is.na(df$padj) &
    		  abs(df$log2FoldChange) < 0.25), ]) != 0) {
	df.dregs = df[!(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold) &
                  !(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold) &
                  !(df$padj > 0.5 & !is.na(df$padj) &
    		  abs(df$log2FoldChange) < 0.25), ]
	df.dregs$response = paste(treat, 'All Other Genes')
	}
	print(head(df.repressed))
	print(head(df.activated))
	print(head(df.dregs))
	print(head(df.unchanged))
    df.effects.lattice = df.activated
    #rbind(df.activated, 
    #      df.unchanged, 
    #      df.repressed, 
    #      df.dregs)
	print(head(df.effects.lattice))
    #df.effects.lattice$response = factor(df.effects.lattice$response)
	#df.effects.lattice$response = relevel(df.effects.lattice$response, ref = paste(treat, 'Unchanged'))
	#df.effects.lattice$response = relevel(df.effects.lattice$response, ref = paste(treat, 'All Other Genes'))
    return(df.effects.lattice)
}
```

In the previous chunk we have created read size table ("XX_reads.txt") of library with same ChIP factor. Another way to estimate read size is to use the `DESeq2` function `estimateSizeFactorsForMatrix` to estimate size factors with robust regression: Each column is divided by the mean of the row. The median of the ratios will be the size factor of the column. \

An example:

```{r engine='bash', eval=F, echo=TRUE}
#GATA3
GATA.SF <- read.table("GATA_reads.txt", sep = '\t', header = TRUE)[,-1]
GATA.size.factors = estimateSizeFactorsForMatrix(GATA.SF)
```


## Counting reads in peaks `

```{r, engine='R', eval=F, echo=TRUE}
# recall that these summit_XXXwindow.bed has the peak region info.
a =  read.table('GATA_ChIP_summit_400window.bed', sep = "\t", header=FALSE)
b1 = read.table('GATActrl_ChIP_summit_400window.bed', sep = "\t", header=FALSE)
b2 = read.table('GATAdegrade_ChIP_summit_400window.bed', sep = "\t", header=FALSE)
c = read.table('ER_ChIP_summit_400window.bed', sep = "\t", header=FALSE)
d = read.table('CTCF_ChIP_summit_400window.bed', sep = "\t", header=FALSE)
e = read.table('CTER_ChIP_summit_400window.bed', sep = "\t", header=FALSE)

#normalized signal
GATA.signal.df= get.counts.interval(a, "./normalized_bw","MCF")
GATActrl.signal.df= get.counts.interval(b1, "./normalized_bw","MCF")
GATAdegrade.signal.df= get.counts.interval(b2, "./normalized_bw","MCF")
ER.signal.df= get.counts.interval(c, "./normalized_bw","MCF")
CTCF.signal.df= get.counts.interval(d, "./normalized_bw","MCF")
CTER.signal.df= get.counts.interval(e, "./normalized_bw","MCF")

#non-normalized counts
GATA.counts.df= get.counts.interval(a, "./non_normalized_bw/non_merge","MCF")

GATActrl.counts.df= get.counts.interval(b1, "./non_normalized_bw/non_merge","MCF")
GATAdegrade.counts.df= get.counts.interval(b2, "./non_normalized_bw/non_merge","MCF")
ER.counts.df= get.counts.interval(c, "./non_normalized_bw/non_merge","MCF")
CTCF.counts.df= get.counts.interval(d, "./non_normalized_bw/non_merge","MCF")
CTER.counts.df= get.counts.interval(e, "./non_normalized_bw/non_merge","MCF")
```

# Counting differential binding 

Differential expression analysis is used to identify gene expression differences across a group of samples (between different biological conditions). The Bioconductor package DEseq2 is commonly used. \

1. GATA Analysis \
```{r, engine='R', eval=F, echo=TRUE}
GATA.analysis.regions=GATA.counts.df[,grepl("_GATA_",colnames(GATA.counts.df))] # non-normalized counts
# identical(rownames(GATA.analysis.regions),rownames(GATA.counts.df))
# [1] TRUE


sample.conditions = factor(sapply(strsplit(colnames(GATA.analysis.regions), '_rep'), '[', 1))
deseq.counts.table = DESeqDataSetFromMatrix(countData = GATA.analysis.regions, # DESeqDataSet needs countData to be non-negative integers; non-normalized counts are integer, normalized signals has decimals.
                colData = as.data.frame(sample.conditions),
                design = ~ sample.conditions)


GATA.SF <- read.table("GATA_reads.txt", sep = '\t', header = TRUE)[,-1] # GATA size factors from read depth
GATA.size.factors = estimateSizeFactorsForMatrix(GATA.SF) # size factor transformed to smaller ratios

sizeFactors(deseq.counts.table) <- GATA.size.factors # assign to each column of the count matrix (deseq.counts.table) the size factor to bring each column to a common scale

dds <- DESeq(deseq.counts.table)
#resultsNames(dds)
#[1] "Intercept"                                                             
#[2] "sample.conditions_MCF7_dTAGGATA522_GATA_CE_vs_MCF7_dTAGGATA522_GATA_CC"
#[3] "sample.conditions_MCF7_dTAGGATA522_GATA_dE_vs_MCF7_dTAGGATA522_GATA_CC"

DE.results = results(dds) # use `contrast` to compare any two groups: contrast = c("Condition", "Treatment", "Control")
DE.results.dEvsCC= results(dds, contrast=c("sample.conditions", "MCF7_dTAGGATA522_GATA_dE", "MCF7_dTAGGATA522_GATA_CC"))
DE.results.CEvsCC= results(dds, contrast=c("sample.conditions", "MCF7_dTAGGATA522_GATA_CE", "MCF7_dTAGGATA522_GATA_CC"))
DE.results.dEvsCE= results(dds, contrast=c("sample.conditions", "MCF7_dTAGGATA522_GATA_dE", "MCF7_dTAGGATA522_GATA_CE"))

save.image('230731_GATA3_ChIP_deseq.Rdata') 
```


```{r, engine='R', eval=F, echo=TRUE}
# notice that the "categorize.deseq.df" function in source file is giving errors: Error in rep_len(xi, nvar) : attempt to replicate non-vector; This seems to be caused by the "rbind" command in the end.
# the activated group gives null obs.
#DE.results.lattice = 
#  categorize.deseq.df.repressed(DE.results, 
#                      fdr = 0.1, log2fold = 0.0, treat =
#                        'GATA3')
#DE.results.lattice2 = 
#    categorize.deseq.df.activated(DE.results, 
#                                  fdr = 0.1, log2fold = 0.0, treat =
#                                      'GATA3')

# CE vs CC
DE.results.lattice.CEvsCC.repressed = 
   categorize.deseq.df.repressed(DE.results.CEvsCC, 
                       fdr = 0.1, log2fold = 0.0, treat =
                      'GATA3_E2_30min')
#DE.results.lattice.CEvsCC.activated = 
#   categorize.deseq.df.activated(DE.results.CEvsCC, 
#                       fdr = 0.1, log2fold = 0.0, treat =
#                      'GATA3_E2_30min') # gives null obs

# dE vs CE
DE.results.lattice.dEvsCE.repressed= 
  categorize.deseq.df.repressed(DE.results.dEvsCE, 
                      fdr = 0.1, log2fold = 0.0, treat =
                        'GATA3_degron_30min')
#DE.results.lattice.CEvsCC.activated = 
#   categorize.deseq.df.activated(DE.results.CEvsCC, 
#                       fdr = 0.1, log2fold = 0.0, treat =
#                      'GATA3_E2_30min') # gives null obs

#identical(DE.results.lattice.dEvsCE.repressed, DE.results.lattice.CEvsCC.repressed)
#[1] FALSE   
```


2. ER analysis \
```{r, engine='R', eval=F, echo=TRUE}
c = read.table('ER_ChIP_summit_400window.bed', sep = "\t", header=FALSE)
#normalized signal
ER.signal.df= get.counts.interval(c, "./normalized_bw","MCF")
#non-normalized counts
ER.counts.df= get.counts.interval(c, "./non_normalized_bw/non_merge","MCF")

ER.analysis.regions=ER.counts.df[,grepl("_ER_",colnames(ER.counts.df))] # non-normalized counts
# identical(rownames(ER.analysis.regions),rownames(ER.counts.df))
# [1] TRUE


sample.conditions = factor(sapply(strsplit(colnames(ER.analysis.regions), '_rep'), '[', 1))
deseq.counts.table = DESeqDataSetFromMatrix(countData = ER.analysis.regions, # DESeqDataSet needs countData to be non-negative integers; non-normalized counts are integer, normalized signals has decimals.
                colData = as.data.frame(sample.conditions),
                design = ~ sample.conditions)


ER.SF <- read.table("ER_reads.txt", sep = '\t', header = TRUE)[,-1] # GATA size factors from read depth
ER.size.factors = estimateSizeFactorsForMatrix(ER.SF) # size factor transformed to smaller ratios

sizeFactors(deseq.counts.table) <- ER.size.factors # assign to each column of the count matrix (deseq.counts.table) the size factor to bring each column to a common scale

dds <- DESeq(deseq.counts.table)
#resultsNames(dds)
#[1] "Intercept"                                                         
#[2] "sample.conditions_MCF7_dTAGGATA522_ER_dE_vs_MCF7_dTAGGATA522_ER_CE"

DE.results = results(dds) # use `contrast` to compare any two groups: contrast = c("Condition", "Treatment", "Control")

save.image('230731_GATA3_ER_ChIP_deseq.Rdata') 
```

# Ranking and quantile parsing of ChIP peaks
Generate BED files that are ranked by their intensity, parsed into separate files, and named according to their quantile.
```{r, engine='R', eval=F, echo=T}
#CTCF_ChIP_summits_final.bed  
#GATA_ChIP_summits_final.bed
#CTER_ChIP_summits_final.bed  
#GATActrl_ChIP_summits_final.bed
#ER_ChIP_summits_final.bed    
#GATAdegrade_ChIP_summits_final.bed
```

1. GATA
```{r, engine='R', eval=F, echo=T}
#mkdir GATA
#cd GATA #current directory: /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/GATA
module load R/4.1.2 
R 
#libraries
library(DESeq2)
library(lattice)
library(dplyr)
library(ggplot2)
library(limma)
library(bigWig)


peak.intensities = read.table('../GATA_ChIP_summits_final.bed', header =FALSE) # GATA_ChIP_summits_final.bed (merged from GATA_CC,CE,dE)
#head(peak.intensities)
#    V1      V2      V3                 V4        V5
#1 chr1  827377  827378  GATA_ChIP_peak_19   3.96575
#2 chr1  845796  845797  GATA_ChIP_peak_20 469.15200
#3 chr1  917533  917534  GATA_ChIP_peak_21  67.72900

chr = peak.intensities$V1
start = peak.intensities$V2
end = peak.intensities$V3

quantile(peak.intensities$V5, probs = seq(.05, 1.00, by = .05))

j =0 
q=seq(.05, 1.00, by = .05)
count=0
for (i in quantile(peak.intensities$V5, probs = seq(.05, 1.00, by =
.05)))
{
count = count +1

write.table(file = paste0('quantile', as.character(q[count]), '.bed'), peak.intensities[peak.intensities$V5 > j & peak.intensities$V5 <= i,], sep = '\t', quote=FALSE, col.names=FALSE, row.names=FALSE )
j = i
}

```

2. ER

```{r, engine='R', eval=F, echo=T}
#mkdir ER
#cd ER #current directory: /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/ER

module load R/4.1.2 
R 
#libraries
library(DESeq2)
library(lattice)
library(dplyr)
library(ggplot2)
library(limma)
library(bigWig)

peak.intensities = read.table('../ER_ChIP_summits_final.bed', header =FALSE) # ER_ChIP_summits_final.bed (merged from ER_CE_2files,dE)

chr = peak.intensities$V1
start = peak.intensities$V2
end = peak.intensities$V3

quantile(peak.intensities$V5, probs = seq(.05, 1.00, by = .05))

j =0 
q=seq(.05, 1.00, by = .05)
count=0
for (i in quantile(peak.intensities$V5, probs = seq(.05, 1.00, by =
.05)))
{
count = count +1

write.table(file = paste0('quantile', as.character(q[count]), '.bed'), peak.intensities[peak.intensities$V5 > j & peak.intensities$V5 <= i,], sep = '\t', quote=FALSE, col.names=FALSE, row.names=FALSE )
j = i
}

```



# Determine functional peaks

##  Integration with PRO-seq data
In the PRO-seq experiment, we have 4 combinations of treatment, either with 30min E2 (to activated the ER activity), or 30min dTAG treatment (to degrade the degron-tagged GATA3): \
In the PRO-seq analysis, we have compared the treatment vs. control as below, and have identified activated/repressed genes, comparable genes that are unchanged but matched for the expression levels.

1) "control_E2"  vs. "control_NoE2": ER activity under control \
2) "dTAGV1_E2"  vs.  "dTAGV1_NoE2" : ER activity when GATA3 is depleted \   
3) "dTAGV1_E2" vs. "control_E2" : compare between with or without GATA3 (when ER is activated) \  
4) "dTAGV1_NoE2" vs. "control_NoE2": compare between with or without GATA3 (when ER is not activated) \ 

Concatenate the activated, repressed, and matched files into a list of activated and repressed genes. \

```{r, engine='R', eval=F, echo=T}
# ER
#MCF7_GATA3_control_E2_vs_control_NoE2_annotations.bed     (compare ER activity when GATA3 is not depleated)
cat control_E2_vs_control_NoE2_activated_genes.bed control_E2_vs_control_NoE2_activated_matched_genes.bed control_E2_vs_control_NoE2_repressed_genes.bed control_E2_vs_control_NoE2_repressed_matched_genes.bed > /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/ER/MCF7_GATA3_control_E2_vs_control_NoE2_annotations.bed  

#MCF7_GATA3_dTAGV1_E2_vs_dTAGV1_NoE2_annotations.bed     (compare ER activity when GATA3 is depleated)
cat dTAGV1_E2_vs_dTAGV1_NoE2_activated_genes.bed dTAGV1_E2_vs_dTAGV1_NoE2_activated_matched_genes.bed dTAGV1_E2_vs_dTAGV1_NoE2_repressed_genes.bed dTAGV1_E2_vs_dTAGV1_NoE2_repressed_matched_genes.bed > /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/ER/MCF7_GATA3_dTAGV1_E2_vs_dTAGV1_NoE2_annotations.bed


#GATA
#MCF7_GATA3_dTAGV1_E2_vs_control_E2_annotations.bed     (degrade GATA3 when ER is activated)
cat dTAGV1_E2_vs_control_E2_activated_genes.bed dTAGV1_E2_vs_control_E2_activated_matched_genes.bed dTAGV1_E2_vs_control_E2_repressed_genes.bed dTAGV1_E2_vs_control_E2_repressed_matched_genes.bed > /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/GATA/MCF7_GATA3_dTAGV1_E2_vs_control_E2_annotations.bed

#MCF7_GATA3_dTAGV1_NoE2_vs_control_NoE2_annotations.bed     (degrade GATA3 when ER is not activated)
cat dTAGV1_NoE2_vs_control_NoE2_activated_genes.bed dTAGV1_NoE2_vs_control_NoE2_activated_matched_genes.bed dTAGV1_NoE2_vs_control_NoE2_repressed_genes.bed dTAGV1_NoE2_vs_control_NoE2_repressed_matched_genes.bed > /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/GATA/MCF7_GATA3_dTAGV1_NoE2_vs_control_NoE2_annotations.bed
```


## Making CDF plots
load key packages
```{r, engine='R', eval=F, echo=T}
#module load R/4.1.2 
#R

library(latticeExtra)
library(DESeq2)
library(lattice)
library(dplyr)
library(ggplot2)
library(limma)
library(bigWig)
#install.packages("gplots")
library(gplots)
source('https://raw.githubusercontent.com/guertinlab/seqOutBias/master/docs/R/seqOutBias_functions.R')
source('https://raw.githubusercontent.com/mjg54/znf143_pro_seq_analysis/master/docs/ZNF143_functions.R')

# cd your/package/directory
#wget https://github.com/arq5x/bedtools2/releases/download/v2.29.1/bedtools-2.29.1.tar.gz
#tar -zxvf bedtools-2.29.1.tar.gz
#cd bedtools2
#make

#source('https://raw.githubusercontent.com/guertinlab/genex/main/ChIP_analysis/cdf_functions.R')
bedTools.closest <- function(functionstring="/home/FCAM/ssun/packages/bedtools2/bin/closestBed",bed1,bed2,opt.string="") {
  
  options(scipen =99) # not to use scientific notation when writing out
  
  #write bed formatted dataframes to tempfile
  write.table(bed1,file= 'a.file.bed', quote=F,sep="\t",col.names=F,row.names=F)
  write.table(bed2,file= 'b.file.bed', quote=F,sep="\t",col.names=F,row.names=F)
  
  # create the command string and call the command using system()
  command1=paste('sort -k1,1 -k2,2n', 'a.file.bed', '> a.file.sorted.bed')
  cat(command1,"\n") #sort -k1,1 -k2,2n a.file.bed > a.file.sorted.bed
  try(system(command1))
  command2=paste('sort -k1,1 -k2,2n', 'b.file.bed', '> b.file.sorted.bed')
  cat(command2,"\n")
  try(system(command2))
  
  command=paste(functionstring, opt.string,"-a",'a.file.sorted.bed',"-b",'b.file.sorted.bed',">",'out.file.bed',sep=" ")
  cat(command,"\n")
  try(system(command))
  
  res=read.table('out.file.bed',header=F, comment.char='')
  
  command3=paste('rm', 'a.file.bed', 'b.file.bed', 'a.file.sorted.bed', 'b.file.sorted.bed', 'out.file.bed')
  cat(command3,"\n")
  try(system(command3))
  
  colnames(res) = c(colnames(bed1), colnames(bed2), 'dis' )
  return(res)
}

cdf.deseq.df <- function(genes = gene.file, chip.peaks = chip.peaks, cat = "Repressed") {
  bed.tss.activated = get.tss(genes[genes$V5 == cat,])
  bed.tss.unchanged = get.tss(genes[genes$V5 == paste0("Matched to ", cat),])
  act.distance = bedTools.closest(bed1 = bed.tss.activated, bed2 = chip.peaks[,c(1:3)], opt.string = '-D a')
  unreg.distance = bedTools.closest(bed1 = bed.tss.unchanged, bed2 = chip.peaks[,c(1:3)], opt.string = '-D a')

  df.up.can = cbind(act.distance[,c(4, 10)], cat)
  #df.un.can = cbind(unreg.distance[,c(4, 10)], paste0("Matched to ", cat))
  df.un.can = cbind(unreg.distance[,c(4, 12)], paste0("Matched to ", cat)) 

  colnames(df.up.can) = c(colnames(df.up.can)[1:2], 'status')
  colnames(df.un.can) = c(colnames(df.up.can)[1:2], 'status')

  df.all = rbind(df.up.can, df.un.can)
  df.all$status = factor(df.all$status, levels = c(cat, paste0("Matched to ", cat)))
  return(df.all)
}


# plot_cdf function has been modified on some plot parameters
plot_cdf <- function(df.all, tf="quantile", cat = "Repressed", col.lines = c("#ce228e", "grey60", "#2290cf","grey90"), line.type = c(1), cex = 1) {
pdf(paste0(tf, "_FIG_cdf_compare_Reg_classes_", cat, ".pdf"), width=10, height=5) 
    print(ecdfplot(~log(abs(dis), base = 10), groups = status, data = df.all,
         auto.key = list(space = "right", lines=TRUE, points=FALSE, cex = cex),
         col = col.lines,
         aspect = 1,
                                        #xlim = c(0, 50000),
         scales=list(relation="free",alternating=c(1,1,1,1)),
         ylab = 'Cumulative Distribution Function',
         xlab = expression('log'[10]~'GATA3 Distance from TSS'),
                                        #index.cond = list(c(2,1)),
         between=list(y=1.0),
         type = 'a',
         xlim = c(0,8),
         lwd=2,
         lty=line.type,
         par.settings = list(superpose.line = list(col = col.lines, lwd=3), strip.background=list(col="grey85")),
         panel = function(...) {
             panel.abline(v= 200, lty =2)
             panel.ecdfplot(...)
         }))
    dev.off()
}
```

#### troubleshoot
```{r, engine='bash', eval=F, echo=F}
cat quantile1.bed | head -5
chr1	845796	845797	GATA_ChIP_peak_20	469.152
chr1	3127377	3127378	GATA_ChIP_peak_51	441.861
chr1	6795912	6795913	GATA_ChIP_peak_82	533.416
chr1	8015165	8015166	GATA_ChIP_peak_101	355.803
chr1	8017664	8017665	GATA_ChIP_peak_102	451.483

> gene.file=read.table(file = "MCF7_GATA3_dTAGV1_E2_vs_control_E2_annotations.bed", sep="\t", header=FALSE)
> head(gene.file)
     V1        V2        V3     V4        V5 V6
1 chr21  42219146  42312524  ABCG1 Activated  +
2 chr20  25270858  25390817 ABHD12 Activated  -
3 chr15  89088485  89218481  ABHD2 Activated  +
4 chr10 114419772 114526910 ABLIM1 Activated  -
5  chr3  38101383  38137077  ACAA1 Activated  -
6 chr11  76860936  77030175  ACER3 Activated  +
  
 get.tss <- function(bedfile) {
    if (ncol(bedfile) > 6) {
        bedfile = bedfile[,c(1:6)]
    }
    for (i in 1:nrow(bedfile)) {
        if (bedfile[i,6] == '+') {
            bedfile[i,3] = bedfile[i,2] + 1
        } else {
            bedfile[i,2] = bedfile[i,3] - 1
        }
    }
    return(bedfile)
 }

> chip.peaks=read.table("/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/GATA/quantile1.bed", header=FALSE)
> head(chip.peaks)
    V1      V2      V3                 V4      V5
1 chr1  845796  845797  GATA_ChIP_peak_20 469.152
2 chr1 3127377 3127378  GATA_ChIP_peak_51 441.861
3 chr1 6795912 6795913  GATA_ChIP_peak_82 533.416
4 chr1 8015165 8015166 GATA_ChIP_peak_101 355.803
5 chr1 8017664 8017665 GATA_ChIP_peak_102 451.483
6 chr1 8182594 8182595 GATA_ChIP_peak_120 364.171

head(bed.tss.activated)
        V1        V2        V3       V4        V5 V6
1037 chr11 106077647 106077648 AASDHPPT Repressed  +
1038  chr9 104928154 104928155    ABCA1 Repressed  -
1039  chr1  94121147  94121148    ABCA4 Repressed  -
1040  chr3 184017883 184017884    ABCC5 Repressed  -
1041  chr1  94418412  94418413    ABCD3 Repressed  +
1042  chr3 132659797 132659798   ACAD11 Repressed  -
> head(bed.tss.unchanged)
        V1        V2        V3     V4                   V5 V6
1528  chr4   8158808   8158809 ABLIM2 Matched to Repressed  -
1529  chr3 195442988 195442989  ACAP2 Matched to Repressed  -
1530 chr11  44066178  44066179   ACCS Matched to Repressed  +
1531  chr4   8428447   8428448  ACOX3 Matched to Repressed  -
1532  chr2    264899    264900   ACP1 Matched to Repressed  +
1533  chr3 179562925 179562926 ACTL6A Matched to Repressed  +
  
   head(act.distance)
    V1       V2       V3       V4        V5 V6   V1       V2       V3     dis
1 chr1 24322507 24322508    GRHL3 Repressed  + chr1 24266771 24266772  -55736
2 chr1 26280085 26280086 SH3BGRL3 Repressed  + chr1 26078702 26078703 -201383
3 chr1 27155124 27155125   SLC9A1 Repressed  - chr1 27145996 27145997    9128
4 chr1 32964812 32964813   RNF19B Repressed  - chr1 33539344 33539345 -574532
5 chr1 33036847 33036848      AK2 Repressed  - chr1 33539344 33539345 -502497
6 chr1 40097251 40097252     PPT1 Repressed  - chr1 40131126 40131127  -33875
  
  > head(unreg.distance)
    V1       V2       V3        V4      V5 V6        V1 V2   V3      dis
1 chr1  1891086  1891087      GNB1 Matched to Repressed  - chr1   845796
2 chr1  9539488  9539489  SLC25A33 Matched to Repressed  + chr1  8182594
3 chr1  9910254  9910255  CTNNBIP1 Matched to Repressed  - chr1  8182594
4 chr1 16921931 16921932     CROCC Matched to Repressed  + chr1 16716791
5 chr1 17539755 17539756 ARHGEF10L Matched to Repressed  + chr1 17475949
6 chr1 20508150 20508151      MUL1 Matched to Repressed  - chr1 20232758
        NA       NA
1   845797  1045290
2  8182595 -1356894
3  8182595  1727660
4 16716792  -205140
5 17475950   -63806
6 20232759   275392
```


### GATA3

1.dTAGV1_E2_vs_control_E2
```{r, engine='R', eval=F, echo=TRUE}
# cd /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/GATA
col.lines = c("#FF0000", "grey60")
gene.file=read.table(file = "MCF7_GATA3_dTAGV1_E2_vs_control_E2_annotations.bed", sep="\t", header=FALSE)

# Repressed genes
cat = "Repressed"

for (chip.peak in Sys.glob(file.path("/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/GATA/quantile*bed"))) {
    print(chip.peak)
    quantile.name = strsplit(strsplit(chip.peak, "/")[[1]][length(strsplit(chip.peak, "/")[[1]])], '.bed')[[1]][1]
    print(quantile.name)
    df.all = cdf.deseq.df(genes = gene.file, chip.peaks=read.table(chip.peak, header=FALSE), cat = cat)
    plot_cdf(df.all, tf = quantile.name, cat = cat)
    }
    
df.cdf = data.frame(matrix(nrow = 0, ncol = 3))     
colnames(df.cdf) = c("V4", "dis", "status")
for (chip.peak in Sys.glob(file.path("/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/GATA/quantile*bed"))) {
    print(chip.peak)
    quantile.name = strsplit(strsplit(chip.peak, "/")[[1]][length(strsplit(chip.peak, "/")[[1]])], '.bed')[[1]][1]
    print(quantile.name)
    df.all = cdf.deseq.df(genes = gene.file,
                          chip.peaks=read.table(chip.peak, header=FALSE),
                          cat = cat)
    x = paste(as.character(df.all[,3]), quantile.name)
    df.all[,3] = x
    df.cdf = rbind(df.cdf, df.all)
    #plot_cdf(df.all, tf = quantile)
    }

plot_cdf(df.cdf, tf = "GATA3_dTAGV1_E2_vs_control_E2", cat = cat, col.lines = c(rep("grey60",20),colorRampPalette(c("red","pink"))(16),colorRampPalette(c("blue", "light blue"))(4)), line.type = c(rep(2, 20), rep(1,20)), cex = 0.5)
#plot_cdf(df.cdf, tf = "ZNF143", cat = cat, col.lines = c(rep("grey60",20),colorRampPalette(c("red","pink"))(20)), line.type = c(rep(2, 20), rep(1,20)), cex = 0.25)

#Activated genes
cat = "Activated"

for (chip.peak in Sys.glob(file.path("/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/GATA/quantile*bed"))) {
    print(chip.peak)
    quantile.name = strsplit(strsplit(chip.peak, "/")[[1]][length(strsplit(chip.peak, "/")[[1]])], '.bed')[[1]][1]
    print(quantile.name)
    df.all = cdf.deseq.df(genes = gene.file, chip.peaks=read.table(chip.peak, header=FALSE), cat = cat)
    plot_cdf(df.all, tf = quantile.name, cat = cat)
    }
    
df.cdf = data.frame(matrix(nrow = 0, ncol = 3))     
colnames(df.cdf) = c("V4", "dis", "status")
for (chip.peak in Sys.glob(file.path("/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/GATA/quantile*bed"))) {
    print(chip.peak)
    quantile.name = strsplit(strsplit(chip.peak, "/")[[1]][length(strsplit(chip.peak, "/")[[1]])], '.bed')[[1]][1]
    print(quantile.name)
    df.all = cdf.deseq.df(genes = gene.file,
        chip.peaks=read.table(chip.peak, header=FALSE),
    cat = cat)
    x = paste(as.character(df.all[,3]), quantile.name)
    df.all[,3] = x
    df.cdf = rbind(df.cdf, df.all)
    #plot_cdf(df.all, tf = quantile)
    }

levels = levels(factor(df.cdf$status))
levels = c(levels[grepl("Matched", levels)], levels[!grepl("Matched", levels)])
df.cdf$status = factor(df.cdf$status, levels = levels)
plot_cdf(df.cdf, tf = "GATA3_dTAGV1_E2_vs_control_E2", cat = cat, col.lines = c(rep("grey60",20),colorRampPalette(c("red","pink"))(20)), line.type = c(rep(2, 20), rep(1,20)), cex = 0.5)
```

choose a cut-off based on the CDF plot \
```{r, engine='R', eval=F, echo=TRUE}
#Let's choose a cutoff of 0.85
#quantiles = quantile(peak.intensities$V5, probs = seq(.05, 1.00, by = .05))
#write.table(quantiles[16][[1]], file = "cutoff.txt", col.names = F, row.names = F, quote = F)
```

2.dTAGV1_NoE2_vs_control_NoE2
```{r, engine='R', eval=F, echo=TRUE}
# cd /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/GATA
col.lines = c("#FF0000", "grey60")
gene.file=read.table(file = "MCF7_GATA3_dTAGV1_NoE2_vs_control_NoE2_annotations.bed", sep="\t", header=FALSE)

```
### ER
1.control_E2_vs_control_NoE2
```{r, engine='R', eval=F, echo=TRUE}
# cd /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/ER
col.lines = c("#FF0000", "grey60")
gene.file=read.table(file = "MCF7_GATA3_control_E2_vs_control_NoE2_annotations.bed", sep="\t", header=FALSE)
```

2.dTAGV1_E2_vs_dTAGV1_NoE2
```{r, engine='R', eval=F, echo=TRUE}
# cd /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/ER
col.lines = c("#FF0000", "grey60")
gene.file=read.table(file = "MCF7_GATA3_dTAGV1_E2_vs_dTAGV1_NoE2_annotations.bed", sep="\t", header=FALSE)
# Repressed genes
cat = "Repressed"

for (chip.peak in Sys.glob(file.path("/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/ER/quantile*bed"))) {
    print(chip.peak)
    quantile.name = strsplit(strsplit(chip.peak, "/")[[1]][length(strsplit(chip.peak, "/")[[1]])], '.bed')[[1]][1]
    print(quantile.name)
    df.all = cdf.deseq.df(genes = gene.file, chip.peaks=read.table(chip.peak, header=FALSE), cat = cat)
    plot_cdf(df.all, tf = quantile.name, cat = cat)
    }
    
df.cdf = data.frame(matrix(nrow = 0, ncol = 3))     
colnames(df.cdf) = c("V4", "dis", "status")
for (chip.peak in Sys.glob(file.path("/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/ER/quantile*bed"))) {
    print(chip.peak)
    quantile.name = strsplit(strsplit(chip.peak, "/")[[1]][length(strsplit(chip.peak, "/")[[1]])], '.bed')[[1]][1]
    print(quantile.name)
    df.all = cdf.deseq.df(genes = gene.file,
        chip.peaks=read.table(chip.peak, header=FALSE),
    cat = cat)
    x = paste(as.character(df.all[,3]), quantile.name)
    df.all[,3] = x
    df.cdf = rbind(df.cdf, df.all)
    #plot_cdf(df.all, tf = quantile)
    }

plot_cdf(df.cdf, tf = "GATA3_dTAGV1_E2_vs_dTAGV1_NoE2", cat = cat, col.lines = c(rep("grey60",20),colorRampPalette(c("red","pink"))(16),colorRampPalette(c("blue", "light blue"))(4)), line.type = c(rep(2, 20), rep(1,20)), cex = 0.5)
#plot_cdf(df.cdf, tf = "ZNF143", cat = cat, col.lines = c(rep("grey60",20),colorRampPalette(c("red","pink"))(20)), line.type = c(rep(2, 20), rep(1,20)), cex = 0.25)

#Activated genes
cat = "Activated"

for (chip.peak in Sys.glob(file.path("/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/ER/quantile*bed"))) {
    print(chip.peak)
    quantile.name = strsplit(strsplit(chip.peak, "/")[[1]][length(strsplit(chip.peak, "/")[[1]])], '.bed')[[1]][1]
    print(quantile.name)
    df.all = cdf.deseq.df(genes = gene.file, chip.peaks=read.table(chip.peak, header=FALSE), cat = cat)
    plot_cdf(df.all, tf = quantile.name, cat = cat)
    }
    
df.cdf = data.frame(matrix(nrow = 0, ncol = 3))     
colnames(df.cdf) = c("V4", "dis", "status")
for (chip.peak in Sys.glob(file.path("/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP1_Sathyan_MCF7_GATA3/4_quantilebed/ER/quantile*bed"))) {
    print(chip.peak)
    quantile.name = strsplit(strsplit(chip.peak, "/")[[1]][length(strsplit(chip.peak, "/")[[1]])], '.bed')[[1]][1]
    print(quantile.name)
    df.all = cdf.deseq.df(genes = gene.file,
        chip.peaks=read.table(chip.peak, header=FALSE),
    cat = cat)
    x = paste(as.character(df.all[,3]), quantile.name)
    df.all[,3] = x
    df.cdf = rbind(df.cdf, df.all)
    #plot_cdf(df.all, tf = quantile)
    }

levels = levels(factor(df.cdf$status))
levels = c(levels[grepl("Matched", levels)], levels[!grepl("Matched", levels)])
df.cdf$status = factor(df.cdf$status, levels = levels)
plot_cdf(df.cdf, tf = "GATA3_dTAGV1_E2_vs_dTAGV1_NoE2", cat = cat, col.lines = c(rep("grey60",20),colorRampPalette(c("red","pink"))(20)), line.type = c(rep(2, 20), rep(1,20)), cex = 0.5)
```

choose a cut-off based on the CDF plot \
```{r, engine='R', eval=F, echo=TRUE}
#Let's choose a cutoff of 0.85
#peak.intensities = read.table('ZNF143_ChIP_summit_counts.bed', header =FALSE)
#quantiles = quantile(peak.intensities$V5, probs = seq(.05, 1.00, by = .05))
#write.table(quantiles[16][[1]], file = "cutoff.txt", col.names = F, row.names = F, quote = F)
```

We can use awk to parse the peak file to only include peaks with intensities above are threshold.
```{r engine='bash', eval=F, echo=TRUE}
#cutoff=$(cat cutoff.txt)
#awk -v cutoff=$cutoff -F"\t" '$5>cutoff' ZNF143_ChIP_summits_final.bed > ZNF143_functional_peaks.bed
#awk -v cutoff=$cutoff -F"\t" '$5<=cutoff' ZNF143_ChIP_summits_final.bed > ZNF143_other_peaks.bed
```


# Fraction of Reads in Peaks (FRiP)

running this part need the functional_peaks.bed and other_peaks.bed from previous section \

## counting reads in peaks 
GATA peaks\
```{r engine='bash', eval=F, echo=TRUE}
#CTCF_ChIP_summit_400window.bed  
#GATA_ChIP_summit_400window.bed
#CTER_ChIP_summit_400window.bed  
#GATActrl_ChIP_summit_400window.bed
#ER_ChIP_summit_400window.bed    
#GATAdegrade_ChIP_summit_400window.bed

for i in *_summit_400window.bed
do
    name=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_summit_400window.bed" '{print $1}')
    nme=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_ChIP_summit_400window.bed" '{print $1}')
    #echo $i
    echo $nme
    echo $name

  sort -k1,1 -k2,2n $i > ${name}_summit_window_sorted.bed
  intersectBed -u -a ${name}_summit_window_sorted.bed -b ${nme}_functional_peaks.bed >  ${name}_functional_summit_window_sorted.bed


  peaks=${name}_functional_summit_window_sorted.bed
  sort -k1,1 -k2,2n $i > ${name}_summit_400window_sorted.bed
  summitWin=${name}_summit_400window_sorted.bed

  for i in *_not_scaled.bed
  do
      nm=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_not_scaled.bed" '{print $1}')
      sort -k1,1 -k2,2n $i > ${nm}_sorted.bed
      mapBed -null '0' -a $peaks -b ${nm}_sorted.bed > ${nm}_peak_counts.txt
      mapBed -null '0' -a $summitWin -b ${nm}_sorted.bed > ${name}_summit_counts.bed
  done

  for i in *_peak_counts.txt
  do
      nam=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_peak_counts.txt" '{print $1}')
      echo $nam > ${nam}_FRiP.txt
      awk '{print $NF}' ${nam}_peak_counts.txt > ${nam}_peak_counts_only.txt
      RiP=$(awk '{sum+=$1;} END{print sum;}' ${nam}_peak_counts_only.txt)
      echo $nam | cat - ${nam}_peak_counts_only.txt > ${nam}_peak_counts.txt
      aligned_reads=$(samtools view -c -f 0x42 ${nam}.bam)
      FRiP=$(echo "scale=2 ; $RiP / $aligned_reads" | bc)
      echo $FRiP >> ${nam}_FRiP.txt
      rm ${nam}_peak_counts_only.txt
  done

  echo -e "chr\tstart\tend\tname\tqvalue" | cat - $peaks | paste -d'\t' - *peak_counts.txt >            Combined_${nme}_peak_counts.txt
  echo -e "Name" > rowname.txt
  echo -e "FrIP" >> rowname.txt
  paste -d'\t' rowname.txt *.hg38_FRiP.txt > Combined_${nme}_FRiP.txt
  rm rowname.txt
done
```

ER peaks \

# heatmap of GATA3 functional and non-functional peaks
deeptools

<!-- 
# ###############################below not runned###############################################
# motif analysis of other and functional ZNF143 peaks


```{r, engine='R', eval=F, echo=T}

chr = sapply(strsplit(names(func.znf143.peaks), ":"), "[", 1)
rnge = sapply(strsplit(names(func.znf143.peaks), ":"), "[", 2)
start =	as.numeric(sapply(strsplit(rnge, "-"), "[", 1)) + 200
end = as.numeric(sapply(strsplit(rnge, "-"), "[", 2)) - 200

write.table(cbind(chr, start, end), file = "ZNF143_functional_peaks.bed", quote = FALSE,
col.names =FALSE, row.names=FALSE, sep = "\t")


chr = sapply(strsplit(names(other.znf143.peaks), ":"), "[", 1)
rnge = sapply(strsplit(names(other.znf143.peaks), ":"), "[", 2)
start =	as.numeric(sapply(strsplit(rnge, "-"), "[", 1)) + 200
end = as.numeric(sapply(strsplit(rnge, "-"), "[", 2)) - 200

write.table(cbind(chr, start, end), file = "ZNF143_other_peaks.bed", quote = FALSE,
col.names =FALSE, row.names=FALSE, sep = "\t")

```


# deeptools heatmap of ZNF143 functional and non-functional peaks

```{r, engine='bash', eval=F, echo=T}

module load deeptools/3.5.0
module load bedtools

#Make the matrix (this can be used for a composite profile as well)
computeMatrix reference-point --referencePoint center -b 500 -a 500 -p 2 --missingDataAsZero \
  -R ZNF143_functional_peaks.bed \
  -S HEK_ZNF-dTAG_cont_HA.bigWig \
  HEK_ZNF-dTAG_dTAGV_HA.bigWig \
  -o matrix_HA_ChIP_ZNF143_peaks.gz --outFileSortedRegions ZNF143_peaks_sorted_for_heatmap.bed
  
#Make the heatmap
plotHeatmap -m matrix_HA_ChIP_ZNF143_peaks.gz -out heatmap_HA_ChIP_ZNF143_peaks.pdf --heatmapHeight 7 \
   --regionsLabel "ZNF143 peaks" --xAxisLabel "Distance from summit" \
   --samplesLabel "DMSO" "dTAG" --colorMap Purples -min 0 -max 300 --whatToShow "heatmap and colorbar" 
   
   
   #Make the matrix (this can be used for a composite profile as well)
computeMatrix reference-point --referencePoint center -b 500 -a 500 -p 2 --missingDataAsZero \
  -R ZNF143_other_peaks.bed \
  -S HEK_ZNF-dTAG_cont_HA.bigWig \
  HEK_ZNF-dTAG_dTAGV_HA.bigWig \
  -o all_matrix_HA_ChIP_ZNF143_peaks.gz --outFileSortedRegions other_ZNF143_peaks_sorted_for_heatmap.bed
  
#Make the heatmap
plotHeatmap -m all_matrix_HA_ChIP_ZNF143_peaks.gz -out other_heatmap_HA_ChIP_ZNF143_peaks.pdf --heatmapHeight 7 \
   --regionsLabel "ZNF143 peaks" --xAxisLabel "Distance from summit" \
   --samplesLabel "DMSO" "dTAG" --colorMap Purples -min 0 -max 300 --whatToShow "heatmap and colorbar" 

#so we can see peaks
plotHeatmap -m all_matrix_HA_ChIP_ZNF143_peaks.gz -out other_heatmap_HA_ChIP_ZNF143_peaks_scaled.pdf --heatmapHeight 7 \
   --regionsLabel "ZNF143 peaks" --xAxisLabel "Distance from summit" \
   --samplesLabel "DMSO" "dTAG" --colorMap Purples -min 0 -max 13 --whatToShow "heatmap and colorbar" 
```


# De novo motif analysis of ZNF143 peaks

I am brute forcing my way through an iterative and exhaustive motif analysis. This should be written into a systematic loop. The reason I did not is because I am manualy looking at the top hit to ensure that it is a ZNF143 motif variant before going on to the next iteration. Any student using this for their work needs to put in the work to automate systematic iterative exhaustive de novo motif analysis.
```{r, engine='bash', eval=F, echo=T}
module load meme/5.4.1
module load bedtools

genome=/home/FCAM/meds5420/genomes/hg38.fa
sizes=/home/FCAM/meds5420/genomes/hg38.chrom.sizes

for i in ZNF143_*_peaks.bed
do
    name=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_peaks.bed" '{print $1}')
    echo $name
    slopBed -b 70 -i $i -g $sizes  | sort -k1,1 -k2,2n > ${name}_summit_140window.bed
    slopBed -b 200 -i $i -g $sizes  | sort -k1,1 -k2,2n > ${name}_summit_400window.bed
    fastaFromBed -fi $genome -bed ${name}_summit_140window.bed -fo ${name}_summit_140window.fasta
done

for i in ZNF143_*_peaks.bed
do
    name=$(echo $i | awk -F"/" '{print $NF}' | awk -F"_peaks.bed" '{print $1}')
    echo $name
    meme -p 16 -oc ${name}_motif_functional.meme_output -nmotifs 1 -objfun classic -csites 20000 -searchsize 0 -minw 10 -maxw 25 -revcomp -dna -markov_order 3 -maxsize 100000000 ${name}_summit_140window.fasta
done


fimo --max-strand --max-stored-scores 10000000 --oc ZNF143_functional_motif_functional.fimo_output ZNF143_functional_motif_functional.meme_output/meme.txt $genome

tail -n +2 ZNF143_functional_motif_functional.fimo_output/fimo.tsv | awk '{OFS="\t";} {print $3,$4,$5,$7,$8,$6}' | grep -v Individual| grep -v format | grep -v "max-stored-scores" | sort -k1,1 -k2,2n | tail -n +2 > fimo_ZNF143_functional_round1.bed

intersectBed -v -wa -a ZNF143_functional_summit_140window.bed -b fimo_ZNF143_functional_round1.bed > ZNF143_ChIP_summit_140window_no_func_motif_1.bed

fastaFromBed -fi $genome -bed ZNF143_ChIP_summit_140window_no_func_motif_1.bed -fo ZNF143_ChIP_summit_140window_no_func_motif_1.fasta

meme -p 16 -oc ZNF143_functional_motif_functional_second.meme_output -nmotifs 1 -objfun classic -csites 20000 -searchsize 0 -minw 10 -maxw 25 -revcomp -dna -markov_order 3 -maxsize 100000000 ZNF143_ChIP_summit_140window_no_func_motif_1.fasta

fimo --max-strand --max-stored-scores 10000000 --oc ZNF143_functional_motif_functional_second.fimo_output ZNF143_functional_motif_functional_second.meme_output/meme.txt $genome

tail -n +2 ZNF143_functional_motif_functional_second.fimo_output/fimo.tsv | awk '{OFS="\t";} {print $3,$4,$5,$7,$8,$6}' | grep -v Individual| grep -v format | grep -v "max-stored-scores" | sort -k1,1 -k2,2n | tail -n +2 > fimo_ZNF143_functional_round2.bed

intersectBed -v -wa -a ZNF143_ChIP_summit_140window_no_func_motif_1.bed -b fimo_ZNF143_functional_round2.bed > ZNF143_ChIP_summit_140window_no_func_motif_1_or_2.bed

fastaFromBed -fi $genome -bed ZNF143_ChIP_summit_140window_no_func_motif_1_or_2.bed -fo ZNF143_ChIP_summit_140window_no_func_motif_1_or_2.fasta

meme -p 16 -oc ZNF143_functional_motif_functional_third.meme_output -nmotifs 1 -objfun classic -csites 20000 -searchsize 0 -minw 10 -maxw 25 -revcomp -dna -markov_order 3 -maxsize 100000000 ZNF143_ChIP_summit_140window_no_func_motif_1_or_2.fasta

#this returned garbage

wc -l ZNF143_ChIP_summit_140window_no_func_motif_1_or_2.bed
wc -l ZNF143_functional_summit_140window.bed

#96% have either motif
# what comparison comparison set of regions can we use as a control?
```


# make a barchart for fraction of peaks with motifs 

```{r engine='bash', eval=F, echo=TRUE}
#input for barchart

rm barchart.txt
for i in quantile*.bed
do
	name=$(echo $i | awk -F"quantile" '{print $NF}' | awk -F".bed" '{print $1}')
	sort -k1,1 -k2,2n $i > tmp.bed
	echo $name 
	intersectBed -u -wa -a tmp.bed -b fimo_ZNF143.bed fimo_ZNF143_motif2.bed > overlap_${name}_znf143.bed
	num=`wc -l overlap_${name}_znf143.bed | cut -f1 -d 'o'`
	tot=`wc -l $i | cut -f1 -d 'q'`
	echo ${num} pos ${name} ZNF143 >> barchart.txt
	neg=$(expr ${tot} - ${num})
	echo ${neg} neg ${name} ZNF143 >> barchart.txt
done


```

####
```{r, engine='R', eval=F, echo=T}


length(peak.intensities[peak.intensities >= quantile(peak.intensities, probs = seq(.05, 1.00, by = .05))[13]])

func.znf143.peaks = peak.intensities[peak.intensities >= quantile(peak.intensities, probs = seq(.05, 1.00, by = .05))[13]]

other.znf143.peaks = peak.intensities[peak.intensities < quantile(peak.intensities, probs = seq(.05, 1.00, by = .05))[13]]

```




# Jinhong: To do

## run through the entire vignette and add context paragraphs and include figures

## make a composite PSWM of motif 1 and motif 2 from the functional peaks

## make a composite FIMO motif signal at peak summits

## de novo motif analysis on other (non-functional peaks)

## Calculate the fraction of reads in peaks (FRiP) score for:

### the full set of ZNF143 narrowPeaks

### functional peaks (use narrowPeaks file)

### other (non-func) peaks (use narrowPeaks file)



```{r engine='R', eval=F, echo=TRUE}


plot.barchart <- function(df.barchart, filename = "~/Desktop/barchart.beds.broadPeaks.pdf") {
  pdf(filename, width=12.83, height=6)

  polycol <- trellis.par.get("superpose.polygon")
  polycol$col <- c("red", "grey40")
  trellis.par.set("superpose.polygon",polycol)


  print(barchart(as.numeric(as.character(fraction))~factor, data = df.barchart, groups=p_n,
                 stack=TRUE,
                 as.table=TRUE,
                 layout=c(1,1),
               #auto.key = list(title = "",rows=3,fill=colors,just="bottom"),
                 main="H3R26Cit Peaks",
               #xlab = "HSF1 or HSF2 Peaks",
                 ylab="Fraction Enriched Red",
                 cex.axis=1.2,
                 between=list(y=0.5, x=0.5),
                 font.axis=1,
                 par.settings=list(par.xlab.text=list(cex=1.0,font=1),
                   par.ylab.text=list(cex=1.0,font=1),
                   axis.text=list(cex=1,font=1),
                   strip.background=list(col="#ecdaf5"),
                   par.main.text=list(cex=1.2, font=1)),
                                        #aspect = 1,
                 scales=list(x=list(alternating=c(1,1,1,0,0,0),rot=45),
                   y=list(alternating=c(1,1)))))
  
  dev.off()
}

```








```{r, engine='R', eval=F, echo=T}

DE.results = results(dds.4)



categorize.deseq.df.repressed <- function(df, fdr = 0.1, log2fold = 0.0, treat
= 'Auxin') {

     df.activated = data.frame(matrix(nrow = 0, ncol = 0))
     df.repressed = data.frame(matrix(nrow = 0, ncol = 0))
	 df.unchanged = data.frame(matrix(nrow = 0, ncol = 0))
     df.dregs = data.frame(matrix(nrow = 0, ncol = 0))
     if (nrow(df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold,]) != 0) {
     	df.activated = df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold,]
	df.activated$response = paste(treat, 'Activated')
	}

     if (nrow(df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold,]) != 0) {
     	df.repressed = df[df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold,]
	df.repressed$response = paste(treat, 'Repressed')
	}
    
    if (nrow(df[df$padj > 0.5 & !is.na(df$padj) & abs(df$log2FoldChange) < 0.25,]) != 0) {
	df.unchanged = df[df$padj > 0.5 & !is.na(df$padj) & abs(df$log2FoldChange) < 0.25,]
    df.unchanged$response = paste(treat, 'Unchanged')
	}

    if (nrow(df[!(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold) &
                  !(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold) &
                  !(df$padj > 0.5 & !is.na(df$padj) &
    		  abs(df$log2FoldChange) < 0.25), ]) != 0) {
	df.dregs = df[!(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange > log2fold) &
                  !(df$padj < fdr & !is.na(df$padj) & df$log2FoldChange < -log2fold) &
                  !(df$padj > 0.5 & !is.na(df$padj) &
    		  abs(df$log2FoldChange) < 0.25), ]
	df.dregs$response = paste(treat, 'All Other Genes')
	}
	print(head(df.repressed))
	print(head(df.activated))
	print(head(df.dregs))
	print(head(df.unchanged))
    df.effects.lattice = df.repressed
    #rbind(df.activated, 
    #      df.unchanged, 
    #      df.repressed, 
    #      df.dregs)
	print(head(df.effects.lattice))
    #df.effects.lattice$response = factor(df.effects.lattice$response)
	#df.effects.lattice$response = relevel(df.effects.lattice$response, ref = paste(treat, 'Unchanged'))
	#df.effects.lattice$response = relevel(df.effects.lattice$response, ref = paste(treat, 'All Other Genes'))
    return(df.effects.lattice)
}






DE.results.lattice = 
    categorize.deseq.df(DE.results, 
                        fdr = 0.1, log2fold = 0.0, treat =
						'ZNF143_degron_30min')
						
DE.results.lattice = 
    categorize.deseq.df.repressed(DE.results, 
                        fdr = 0.1, log2fold = 0.0, treat = 'ZNF143_degron_30min')						
						
head(DE.results.lattice)
repressed.all = DE.results.lattice[DE.results.lattice$response == 
                                             'ZNF143_degron_30min Repressed',]
dim(repressed.all)

activated.all = DE.results.lattice[DE.results.lattice$response == 
                                             'ZNF143_degron_30min Activated',]
dim(activated.all)
# what is happening in these 213 regions? likely no ZNF143 motif

ma.plot.lattice(DE.results.lattice, filename = 'ZNF143_30min_degradation_SF', 
        title.main = "Differential Binding", ymin=-12, ymax=4)		
		

DE.results = results(dds.4)
# also get un normalized ZNF143 MA plot.

#NEXT FOR EACH QUANTILE PLOT THE FRACTION THAT SIGNIFICANTLY DECREASE INTENSITY

#goal is to use a combination of peaks with motifs in each quantile
and sensitivity to depleteion to get a peak cut off.
STOPPED HERE


#make a MA plot without normalized SF to show theimportance of PF chip
# de novo motif analysi sof the NOT ACTIVATED to see if the ZNF143
#motif comes out. If so we are being too conservative in the
#differntial binding analysis and recommend moving to aligned Reads as
#size factors

DE.results = results(dds)

head(DE.results)

DE.results.lattice = 
    categorize.deseq.df(DE.results, 
                        fdr = 0.1, log2fold = 0.0, treat = 'ZNF143_degron_30min')

head(DE.results.lattice)


repressed.all = DE.results.lattice[DE.results.lattice$response == 
                                             'ZNF143_degron_30min Repressed',]

dim(repressed.all)


ma.plot.lattice(DE.results.lattice, filename = 'ZNF143_30min_degradation', 
        title.main = "Differential Binding")		
		
#we are not ranking by fold change, so no need for shrinkage

#lets export a smaller genomic interval for each region for subsequent motif analysis

chr = sapply(strsplit(rownames(activated.all), ":"), "[", 1)
rnge = sapply(strsplit(rownames(activated.all), ":"), "[", 2)
start =	as.numeric(sapply(strsplit(rnge, "-"), "[", 1)) + 100
end = as.numeric(sapply(strsplit(rnge, "-"), "[", 2)) - 100

write.table(cbind(chr, start, end), file = "ATAC_increase_TRPS1_degron.bed", quote = FALSE,
col.names =FALSE, row.names=FALSE, sep = "\t")


unchanged.all = DE.results.lattice[DE.results.lattice$response == 
                                             'TRPS1_degron_30min Unchanged',]
											 
chr.un = sapply(strsplit(rownames(unchanged.all), ":"), "[", 1)
rnge.un = sapply(strsplit(rownames(unchanged.all), ":"), "[", 2)
start.un =	as.numeric(sapply(strsplit(rnge.un, "-"), "[", 1)) + 100
end.un = as.numeric(sapply(strsplit(rnge.un, "-"), "[", 2)) - 100

write.table(cbind(chr.un, start.un, end.un), file = "ATAC_unchanged_TRPS1_degron.bed", quote = FALSE,
col.names =FALSE, row.names=FALSE, sep = "\t")



#motifs
with.motif = read.table('ZNF143_ChIP_summit_140window_w_motifs.bed', sep = "\t", header=FALSE)
no.motif = read.table('ZNF143_ChIP_summit_140window_no_motifs.bed', sep = "\t", header=FALSE)
with.motif = cbind(with.motif, 'ZNF143 Motif')
no.motif = cbind(no.motif, 'No Motif')

colnames(with.motif) = c('chr', 'start', 'end', 'peak', 'strength', 'category')
colnames(no.motif) = c('chr', 'start', 'end', 'peak', 'strength', 'category')

motif.strength = rbind(with.motif, no.motif)

densityplot(~log(strength, base = 10), data=motif.strength,
	groups = category,
       xlab="Peak Intensity",
        scales="free",
		par.settings = list(superpose.line = list(col = c("#5304a0","#0e930a"))),
   aspect=1, lwd =3,
       plot.points=FALSE,auto.key=TRUE,
	   panel=function(x,...){
      panel.densityplot(x,...)
      panel.abline(v=1, col.line="red", lty = 2) 
    })
#remove those with intensities less than 10 (no motif)

#data processing and plotting
#just calculate sizeFactors from read depth
#use aligned read depth


```

 don't use below 0.7 quantile

62 fold dynamic range, there is littel evidence of PRO changes near
genes below 1.6% of the max peak height








# DID NOT DO THIS YET De novo motif analysis of differential peaks

Lastly, we perform _de novo_ motif analysis as we have previously with
`meme`. We can also determine the fraction of regions with immediate
increases in accessibility have the underlying motif. However, this
value is meaningless without a comparison. We could compare to
`TRPS1_degron_30min Unchanged` region set.

```{r engine='bash', eval=F, echo=TRUE}
module load bedtools
#NEXT 
#do meme on those without a canonical ZNF143

rm barchart.txt
for i in quantile*.bed
do
	name=$(echo $i | awk -F"quantile" '{print $NF}' | awk -F".bed" '{print $1}')
	sort -k1,1 -k2,2n $i > tmp.bed
	echo $name 
	intersectBed -u -wa -a tmp.bed -b fimo_ZNF143.bed fimo_ZNF143_motif2.bed > overlap_${name}_znf143.bed
	num=`wc -l overlap_${name}_znf143.bed | cut -f1 -d 'o'`
	tot=`wc -l $i | cut -f1 -d 'q'`
	echo ${num} pos ${name} ZNF143 >> barchart.txt
	neg=$(expr ${tot} - ${num})
	echo ${neg} neg ${name} ZNF143 >> barchart.txt
done

num	p_n	b_f	factor	fraction
66	pos	bottom	BEAF_70	  .04737975
0	neg	bottom	BEAF_70	  0
1327	neu	bottom	BEAF_70	  .95262025

```




```{r engine='bash', eval=F, echo=TRUE}
genome=/home/FCAM/meds5420/genomes/hg38.fa
module load bedtools

for i in quantile*.bed
do
	name=$(echo $i | awk -F"/" '{print $NF}' | awk -F".bed" '{print $1}')
	echo $name
	fastaFromBed -fi $genome -bed $i -fo $name.fasta
done

DO MAST IN THESE WITH THE TOP DE NOVO MOTIF.

```


 
```{r engine='bash', eval=F, echo=TRUE}

#Defined functional TRPS1 peaks by MACS2 q-value < 10^(-30)
awk '$5 > 30' /scratch/ts2hx/ChIP/results/macs2/HA_DMSO_vs_dTAG_summits.bed > \
  Functional_TRPS1_summits.bed

#Make the matrix (this can be used for a composite profile as well)
computeMatrix reference-point --referencePoint center -b 500 -a 500 -p 20 --missingDataAsZero \
  -R ZNF143_ChIP_summits_final.bed \
  -S HEK_ZNF-dTAG_cont_HA.bigWig \
  HEK_ZNF-dTAG_dTAGV_HA.bigWig \
  -o matrix_HA_ChIP_ZNF143_peaks.gz --outFileSortedRegions ZNF143_peaks_sorted_for_heatmap.bed
  
#Make the heatmap
plotHeatmap -m matrix_HA_ChIP_ZNF143_peaks.gz -out heatmap_HA_ChIP_ZNF143_peaks.pdf --heatmapHeight 14 \
   --regionsLabel "ZNF143 peaks" --xAxisLabel "Distance from summit" \
   --samplesLabel "DMSO" "dTAG" --colorMap Purples --whatToShow "heatmap and colorbar" 

```

Now we want to identify all CTCF peaks that are distal to ZNF143
binding sites and identify all ZNF143 peaks.

```{r engine='bash', eval=F, echo=TRUE}
module load bedtools
intersectBed -wa -v -a ZNF143_ChIP_peaks.narrowPeak -b CTCF_ChIP_peaks.narrowPeak > ZNF_away_CTCF.narrowPeak
intersectBed -wa -v -a CTCF_ChIP_peaks.narrowPeak -b ZNF143_ChIP_peaks.narrowPeak > CTCF_away_ZNF.narrowPeak
intersectBed -wa -a CTCF_ChIP_summit_400window.bed -b CTCF_away_ZNF.narrowPeak | sort -k1,1 -k2,2n | uniq > CTCF_ChIP_summit_400window_isolated.bed


closestBed -d -a ZNF143_ChIP_summit_400window.bed -b CTCF_ChIP_summits_final.bed | awk '{OFS="\t";} {print $1, $2, $3, $11}' > ZNF143_CTCFdistance.bed

genome=/home/FCAM/meds5420/genomes/hg38.fa
fastaFromBed -fi $genome -bed ZNF143_ChIP_summit_140window.bed -fo ZNF143_ChIP_summit_140window.fasta

# inputs to bigWig in R
head CTCF_ChIP_summit_400window_isolated.bed
head ZNF143_ChIP_summit_400window.bed


#size factors

module load samtools/1.12
for i in HA
do
  echo $i
  > ${i}_header.txt
  > ${i}_reads.txt
  for j in HEK_ZNF-dTAG*_${i}_*.bam
  do
    echo $j
    name=$(echo $j | awk -F".sorted.bam" '{print $1}')
    echo $name | paste ${i}_header.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_header.txt
    reads=`samtools view -c -f 0x3 $j`
    echo $reads | paste ${i}_reads.txt - > ${i}_tmp.txt 
    mv ${i}_tmp.txt ${i}_reads.txt
  done  
  cat ${i}_header.txt ${i}_reads.txt > ${i}_tmp.txt
  mv ${i}_tmp.txt ${i}_reads.txt
  rm ${i}_header.txt
done 

```



# De novo motif analysis of ZNF143 peaks

I am brute forcing my way through an iterative and exhaustive motif
analysis. I need to write this into a systematic loop. The reason I
did not is because I am manualy looking at the top hit to ensure that
it is a ZNF143 motif variant before going on to the next iteration.

```{r engine='bash', eval=F, echo=TRUE}
module load meme/5.4.1
genome=/home/FCAM/meds5420/genomes/hg38.fa

meme -p 16 -oc ZNF143_motif1.meme_output -nmotifs 3 -objfun classic -csites 20000 -searchsize 0 -minw 10 -maxw 25 -revcomp -dna -markov_order 3 -maxsize 100000000 ZNF143_ChIP_summit_140window.fasta

fimo --motif CTGGGAAATGTAGT --max-strand --max-stored-scores 10000000 --oc fimo_ZNF143 ZNF143_csites.meme_output/meme.txt $genome

tail -n +2 fimo.tsv | awk '{OFS="\t";} {print $3,$4,$5,$7,$8,$6}' | grep -v Individual| grep -v CTGGGAAATGTAGT | grep -v format | sort -k1,1 -k2,2n | tail -n +2 > fimo_ZNF143.bed
 
intersectBed -v -wa -a ZNF143_ChIP_summit_140window.bed -b fimo_ZNF143.bed > ZNF143_ChIP_summit_140window_no_motif1.bed
 
fastaFromBed -fi $genome -bed ZNF143_ChIP_summit_140window_no_motif1.bed -fo ZNF143_ChIP_summit_140window_no_motif1.fasta
 
meme -p 16 -oc ZNF143_motif2.meme_output -nmotifs 3 -objfun classic -csites 20000 -searchsize 0 -minw 10 -maxw 25 -revcomp -dna -markov_order 3 -maxsize 100000000 ZNF143_ChIP_summit_140window_no_motif1.fasta

fimo --thresh 0.001 --motif YTCCCAGMATSCHYYGCG --max-strand --max-stored-scores 10000000 --oc fimo_ZNF143_motif1 ZNF143_motif2.meme_output/meme.txt $genome

tail -n +2 fimo_ZNF143_motif1/fimo.tsv | awk '{OFS="\t";} {print $2,$3,$4,$6,$7,$5}' | grep -v Individual| grep -v YTCCCAGMATSCHYYGCG | grep -v format | sort -k1,1 -k2,2n | tail -n +2 > fimo_ZNF143_motif2.bed
 
intersectBed -v -wa -a ZNF143_ChIP_summit_140window.bed -b fimo_ZNF143.bed fimo_ZNF143_motif2.bed > ZNF143_ChIP_summit_140window_no_motifs.bed

fastaFromBed -fi $genome -bed ZNF143_ChIP_summit_140window_no_motifs.bed -fo ZNF143_ChIP_summit_140window_no_motifs.fasta
 
meme -p 16 -oc ZNF143_motif3.meme_output -nmotifs 3 -objfun classic -csites 20000 -searchsize 0 -minw 10 -maxw 25 -revcomp -dna
-markov_order 3 -maxsize 100000000 ZNF143_ChIP_summit_140window_no_motifs.fasta

fimo --thresh 0.0001 --motif SMVVVNNVRRRACTACATTTCCCAG --max-strand --max-stored-scores 10000000 --oc fimo_ZNF143_motif3 ZNF143_motif3.meme_output/meme.txt $genome

#stopped here

tail -n +2 fimo_ZNF143_motif3/fimo.tsv | awk '{OFS="\t";} {print $3,$4,$5,$7,$8,$6}' | grep -v Individual| grep -v SMVVVNNVRRRACTACATTTCCCAG | grep -v format | sort -k1,1 -k2,2n | tail -n +2 > fimo_ZNF143_motif3.bed


#the above should be in some sort of loop, but at least rechecked, because I hacked it together

intersectBed -v -a ZNF143_ChIP_summit_140window.bed -b fimo_ZNF143.bed fimo_ZNF143_motif2.bed fimo_ZNF143_motif3.bed > ZNF143_ChIP_summit_140window_no_motifs.bed

intersectBed -wa -u -a ZNF143_ChIP_summit_140window.bed -b fimo_ZNF143.bed fimo_ZNF143_motif2.bed fimo_ZNF143_motif3.bed > ZNF143_ChIP_summit_140window_w_motifs.bed
```



x = read.table('CTCF_ChIP_summit_400window_isolated.bed', sep = "\t", header=FALSE)
y = read.table('ZNF143_ChIP_summit_400window.bed', sep = "\t", header=FALSE)

x = x[((ctcf.signal.df[,'HEK_ZNF-dTAG_cont_CTCF']/ctcf.signal.df[,'HEK_ZNF-dTAG_cont_IgG'])>10) & ctcf.signal.df[,'HEK_ZNF-dTAG_cont_CTCF'] > max(ctcf.signal.df[,'HEK_ZNF-dTAG_cont_CTCF']/200),]

z = read.table('ZNF143_CTCFdistance.bed', sep = "\t", header=FALSE)

z.regions=paste0(z[,1],z[,2])
y.regions=paste0(y[,1],y[,2])

z =z[z.regions %in% y.regions,]
z.regions=paste0(z[,1],z[,2])
z =z[!duplicated(z.regions),]

distal.znf143 = z[z[,4]<2000,]


intervals.znf = paste(distal.znf143[,1], ':', distal.znf143[,2], '-', distal.znf143[,3], sep='')
distal.znf143 = distal.znf143[!duplicated(intervals.znf),]
intervals.znf = intervals.znf[!duplicated(intervals.znf)]




DE.results.1 = results(dds, contrast=c("sample.conditions","HEK_ZNF-dTAG_cont_CTCF","HEK_ZNF-dTAG_cont_HACTCF")) 

DE.results.lattice.1 = 
    categorize.deseq.df(DE.results.1, 
                        fdr = 0.1, log2fold = 0.0, treat = 'ZNF143_degron_30min_CTCF')
ma.plot.lattice(DE.results.lattice.1, filename = 'ZNF143_30min_degradation_CTCFpeaks_SFcont_CTCF_vs_HACTCF', 
        title.main = "Differential Binding", ymin=-6, ymax=6)	

#is every peak repressed on this near a ZNF143 binding site that we did not call?
#motif analysis

DE.results.11 = results(dds, contrast=c("sample.conditions","HEK_ZNF-dTAG_cont_CTCF","HEK_ZNF-dTAG_dTAGV_CTCF")) 

DE.results.lattice.11 = 
    categorize.deseq.df(DE.results.11, 
                        fdr = 0.1, log2fold = 0.0, treat = 'ZNF143_degron_30min_CTCF')
ma.plot.lattice(DE.results.lattice.11, filename = 'ZNF143_30min_degradation_CTCFpeaks_SF_CTCF_ctrl_degron', 
        title.main = "Differential Binding", ymin=-6, ymax=6)	


DE.results.12 = results(dds, contrast=c("sample.conditions","HEK_ZNF-dTAG_dTAGV_CTCF","HEK_ZNF-dTAG_dTAGV_HACTCF")) 

DE.results.lattice.12 = 
    categorize.deseq.df(DE.results.12, 
                        fdr = 0.1, log2fold = 0.0, treat = 'ZNF143_degron_30min_CTCF')
ma.plot.lattice(DE.results.lattice.12, filename = 'ZNF143_30min_degradation_CTCFpeaks_SF_CTCF_pf_degron', 
        title.main = "Differential Binding", ymin=-6, ymax=6)	



DE.results.13 = results(dds, contrast=c("sample.conditions","HEK_ZNF-dTAG_dTAGV_HACTCF","HEK_ZNF-dTAG_dTAGV_HACTCF")) 

DE.results.lattice.13 = 
    categorize.deseq.df(DE.results.13, 
                        fdr = 0.1, log2fold = 0.0, treat = 'ZNF143_degron_30min_CTCF')
ma.plot.lattice(DE.results.lattice.13, filename = 'ZNF143_30min_degradation_CTCFpeaks_SF_upon_degron_CTCF_vs_CTCF', 
        title.main = "Differential Binding", ymin=-6, ymax=6)	



#this needs to be filtered for ZNF143 peaks beign considered.
#???--this is ALL FUCKED UP
#control HA SF

#FEM1A is a good pfChIP 

ctrl.znf143 = c("chr5:173616547-173616948", "chr12:6852316-6852717", "chr1:156767180-156767581")

contHA.all.regions=all.regions[,grepl("cont_HA",colnames(all.regions))]
sample.conditions = factor(sapply(strsplit(colnames(contHA.all.regions), '_rep'), '[', 1))
deseq.counts.table.2 = DESeqDataSetFromMatrix(countData = contHA.all.regions,
                colData = as.data.frame(sample.conditions), 
                design = ~ sample.conditions)

#dds.2 <- estimateSizeFactors(deseq.counts.table.2, controlGenes=rownames(deseq.counts.table.2) %in% intervals.znf)
dds.2 <- estimateSizeFactors(deseq.counts.table.2, controlGenes=rownames(deseq.counts.table.2) %in% ctrl.znf143)
dds.2 <- DESeq(dds.2)

znfpeaks.SF = dds.2$sizeFactor

DE.results.2 = results(dds.2)
DE.results.lattice.2 = 
    categorize.deseq.df(DE.results.2, 
                        fdr = 0.1, log2fold = 0.0, treat = 'ZNF143_degron_30min')
ma.plot.lattice(DE.results.lattice.2, filename = 'ZNF143_30min_degradation_ZNFpeaks_SF', 
        title.main = "Differential Binding", ymin=-6, ymax=6)		
		
#it is clear from this MA plot that the ZNF143 overlap CTCF somewhat.




#degron HA SF
dtagHA.all.regions=all.regions[,grepl("dTAGV_HA",colnames(all.regions))]
sample.conditions = factor(sapply(strsplit(colnames(dtagHA.all.regions), '_rep'), '[', 1))
deseq.counts.table.3 = DESeqDataSetFromMatrix(countData = dtagHA.all.regions,
                colData = as.data.frame(sample.conditions), 
                design = ~ sample.conditions)
				

#dds.3 <- estimateSizeFactors(deseq.counts.table.3, controlGenes=rownames(deseq.counts.table.3) %in% intervals.znf)
dds.3 <- estimateSizeFactors(deseq.counts.table.3, controlGenes=rownames(deseq.counts.table.3) %in% ctrl.znf143)
dds.3 <- DESeq(dds.3)


DE.results.3 = results(dds.3)
DE.results.lattice.3 = 
    categorize.deseq.df(DE.results.3, 
                        fdr = 0.1, log2fold = 0.0, treat = 'ZNF143_degron_30min')
ma.plot.lattice(DE.results.lattice.3, filename = 'ZNF143_30min_degradation_ZNFpeaks_degron_SF', 
        title.main = "Differential Binding", ymin=-8, ymax=8)		
		




degronpeaks.SF = dds.3$sizeFactor
names(degronpeaks.SF)
names(znfpeaks.SF)
names(anchor.SF)

anchor.SF[names(anchor.SF) %in% names(degronpeaks.SF)]
degronpeaks.SF[names(degronpeaks.SF) %in% names(anchor.SF)]
mean.anchor.SF = mean(anchor.SF[names(anchor.SF) %in% names(degronpeaks.SF)])
mean.degron.SF = mean(degronpeaks.SF[names(degronpeaks.SF) %in% names(anchor.SF)])

norm.degronpeaks.SF = degronpeaks.SF *(mean.anchor.SF/mean.degron.SF)



anchor.SF[names(anchor.SF) %in% names(znfpeaks.SF)]
znfpeaks.SF[names(znfpeaks.SF) %in% names(anchor.SF)]
mean.anchor.SF = mean(anchor.SF[names(anchor.SF) %in% names(znfpeaks.SF)])
mean.degron.SF = mean(znfpeaks.SF[names(znfpeaks.SF) %in% names(anchor.SF)])

norm.znfpeaks.SF = znfpeaks.SF *(mean.anchor.SF/mean.degron.SF)

#then maybe we average the common SF and incorporate these new ones and compare to read depth SF?

all.SF = rep(NA, 21)
all.SF[1:6] = anchor.SF[1:6]
all.SF[4:6] = (anchor.SF[4:6]+norm.znfpeaks.SF[1:3])/2
all.SF[7:9] = norm.znfpeaks.SF[4:6]
#10:12 are IgG
all.SF[13:15] = anchor.SF[7:9]
all.SF[16:18] = (anchor.SF[10:12]+norm.degronpeaks.SF[1:3])/2
all.SF[19:21] = norm.degronpeaks.SF[4:6]
names(all.SF) = colnames(all.regions)

-->
